var Ms = Object.defineProperty;
var Ws = (n, e, t) => e in n ? Ms(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var Fe = (n, e, t) => (Ws(n, typeof e != "symbol" ? e + "" : e, t), t);
import qe, { createContext as Ur, useContext as ee, useEffect as Xe, useLayoutEffect as Hs, useRef as Be, useMemo as qr, useCallback as M, useDebugValue as Ys, useState as P } from "react";
var F = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Yt = {}, rt = {}, ft = {}, le = F && F.__assign || function() {
  return le = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, le.apply(this, arguments);
}, wt = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Et = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(ft, "__esModule", { value: !0 });
ft.FrappeCall = void 0;
var Js = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.get = function(e, t) {
    return wt(this, void 0, void 0, function() {
      return Et(this, function(r) {
        return [2, this.axios.get("/api/method/".concat(e), { params: t }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw le(le({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.post = function(e, t) {
    return wt(this, void 0, void 0, function() {
      return Et(this, function(r) {
        return [2, this.axios.post("/api/method/".concat(e), le({}, t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw le(le({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.put = function(e, t) {
    return wt(this, void 0, void 0, function() {
      return Et(this, function(r) {
        return [2, this.axios.put("/api/method/".concat(e), le({}, t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw le(le({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.delete = function(e, t) {
    return wt(this, void 0, void 0, function() {
      return Et(this, function(r) {
        return [2, this.axios.delete("/api/method/".concat(e), { params: t }).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw le(le({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error.", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n;
}();
ft.FrappeCall = Js;
var ht = {}, z = F && F.__assign || function() {
  return z = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, z.apply(this, arguments);
}, Ie = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Ue = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(ht, "__esModule", { value: !0 });
ht.FrappeDB = void 0;
var zs = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.getDoc = function(e, t) {
    return t === void 0 && (t = ""), Ie(this, void 0, void 0, function() {
      return Ue(this, function(r) {
        return [2, this.axios.get("/api/resource/".concat(e, "/").concat(t)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o;
          throw z(z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: "There was an error while fetching the document.", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.getDocList = function(e, t) {
    var r;
    return Ie(this, void 0, void 0, function() {
      var s, i, o, c, f, a, h, l, p, v, b;
      return Ue(this, function(w) {
        return s = {}, t && (i = t.fields, o = t.filters, c = t.orFilters, f = t.orderBy, a = t.limit, h = t.limit_start, l = t.groupBy, p = t.asDict, v = p === void 0 ? !0 : p, b = f ? "".concat(String(f == null ? void 0 : f.field), " ").concat((r = f == null ? void 0 : f.order) !== null && r !== void 0 ? r : "asc") : "", s = {
          fields: i ? JSON.stringify(i) : void 0,
          filters: o ? JSON.stringify(o) : void 0,
          or_filters: c ? JSON.stringify(c) : void 0,
          order_by: b,
          group_by: l,
          limit: a,
          limit_start: h,
          as_dict: v
        }), [2, this.axios.get("/api/resource/".concat(e), { params: s }).then(function(x) {
          return x.data.data;
        }).catch(function(x) {
          var g, T;
          throw z(z({}, x.response.data), { httpStatus: x.response.status, httpStatusText: x.response.statusText, message: "There was an error while fetching the documents.", exception: (T = (g = x.response.data.exception) !== null && g !== void 0 ? g : x.response.data.exc_type) !== null && T !== void 0 ? T : "" });
        })];
      });
    });
  }, n.prototype.createDoc = function(e, t) {
    return Ie(this, void 0, void 0, function() {
      return Ue(this, function(r) {
        return [2, this.axios.post("/api/resource/".concat(e), z({}, t)).then(function(s) {
          return s.data.data;
        }).catch(function(s) {
          var i, o, c;
          throw z(z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : "There was an error while creating the document.", exception: (c = (o = s.response.data.exception) !== null && o !== void 0 ? o : s.response.data.exc_type) !== null && c !== void 0 ? c : "" });
        })];
      });
    });
  }, n.prototype.updateDoc = function(e, t, r) {
    return Ie(this, void 0, void 0, function() {
      return Ue(this, function(s) {
        return [2, this.axios.put("/api/resource/".concat(e, "/").concat(t), z({}, r)).then(function(i) {
          return i.data.data;
        }).catch(function(i) {
          var o, c, f;
          throw z(z({}, i.response.data), { httpStatus: i.response.status, httpStatusText: i.response.statusText, message: (o = i.response.data.message) !== null && o !== void 0 ? o : "There was an error while updating the document.", exception: (f = (c = i.response.data.exception) !== null && c !== void 0 ? c : i.response.data.exc_type) !== null && f !== void 0 ? f : "" });
        })];
      });
    });
  }, n.prototype.deleteDoc = function(e, t) {
    return Ie(this, void 0, void 0, function() {
      return Ue(this, function(r) {
        return [2, this.axios.delete("/api/resource/".concat(e, "/").concat(t)).then(function(s) {
          return s.data;
        }).catch(function(s) {
          var i, o;
          throw z(z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: "There was an error while deleting the document.", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : "" });
        })];
      });
    });
  }, n.prototype.getCount = function(e, t, r, s) {
    return r === void 0 && (r = !1), s === void 0 && (s = !1), Ie(this, void 0, void 0, function() {
      var i;
      return Ue(this, function(o) {
        return i = {
          doctype: e,
          filters: []
        }, r && (i.cache = r), s && (i.debug = s), t && (i.filters = t ? JSON.stringify(t) : void 0), [2, this.axios.get("/api/method/frappe.client.get_count", { params: i }).then(function(c) {
          return c.data.message;
        }).catch(function(c) {
          var f, a;
          throw z(z({}, c.response.data), { httpStatus: c.response.status, httpStatusText: c.response.statusText, message: "There was an error while getting the count.", exception: (a = (f = c.response.data.exception) !== null && f !== void 0 ? f : c.response.data.exc_type) !== null && a !== void 0 ? a : "" });
        })];
      });
    });
  }, n.prototype.getLastDoc = function(e, t) {
    return Ie(this, void 0, void 0, function() {
      var r, s;
      return Ue(this, function(i) {
        switch (i.label) {
          case 0:
            return r = {
              orderBy: {
                field: "creation",
                order: "desc"
              }
            }, t && (r = z(z({}, r), t)), [4, this.getDocList(e, z(z({}, r), { limit: 1, fields: ["name"] }))];
          case 1:
            return s = i.sent(), s.length > 0 ? [2, this.getDoc(e, s[0].name)] : [2, {}];
        }
      });
    });
  }, n;
}();
ht.FrappeDB = zs;
var dt = {}, Pt = F && F.__assign || function() {
  return Pt = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, Pt.apply(this, arguments);
}, Ks = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, Gs = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.FrappeFileUpload = void 0;
var Xs = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.uploadFile = function(e, t, r) {
    return Ks(this, void 0, void 0, function() {
      var s, i, o, c, f, a, h;
      return Gs(this, function(l) {
        return s = new FormData(), e && s.append("file", e, e.name), i = t.isPrivate, o = t.folder, c = t.file_url, f = t.doctype, a = t.docname, h = t.fieldname, i && s.append("is_private", "1"), o && s.append("folder", o), c && s.append("file_url", c), f && a && (s.append("doctype", f), s.append("docname", a), h && s.append("fieldname", h)), [2, this.axios.post("/api/method/upload_file", s, {
          onUploadProgress: function(p) {
            r && r(p.loaded, p.total);
          }
        }).catch(function(p) {
          var v, b;
          throw Pt(Pt({}, p.response.data), { httpStatus: p.response.status, httpStatusText: p.response.statusText, message: (v = p.response.data.message) !== null && v !== void 0 ? v : "There was an error while uploading the file.", exception: (b = p.response.data.exception) !== null && b !== void 0 ? b : "" });
        })];
      });
    });
  }, n;
}();
dt.FrappeFileUpload = Xs;
var Ge = {}, Vr = { exports: {} }, Dn = { exports: {} }, jr = function(e, t) {
  return function() {
    for (var s = new Array(arguments.length), i = 0; i < s.length; i++)
      s[i] = arguments[i];
    return e.apply(t, s);
  };
}, Qs = jr, ke = Object.prototype.toString;
function kn(n) {
  return Array.isArray(n);
}
function gn(n) {
  return typeof n > "u";
}
function Zs(n) {
  return n !== null && !gn(n) && n.constructor !== null && !gn(n.constructor) && typeof n.constructor.isBuffer == "function" && n.constructor.isBuffer(n);
}
function $r(n) {
  return ke.call(n) === "[object ArrayBuffer]";
}
function ei(n) {
  return ke.call(n) === "[object FormData]";
}
function ti(n) {
  var e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && $r(n.buffer), e;
}
function ni(n) {
  return typeof n == "string";
}
function ri(n) {
  return typeof n == "number";
}
function Mr(n) {
  return n !== null && typeof n == "object";
}
function At(n) {
  if (ke.call(n) !== "[object Object]")
    return !1;
  var e = Object.getPrototypeOf(n);
  return e === null || e === Object.prototype;
}
function si(n) {
  return ke.call(n) === "[object Date]";
}
function ii(n) {
  return ke.call(n) === "[object File]";
}
function oi(n) {
  return ke.call(n) === "[object Blob]";
}
function Wr(n) {
  return ke.call(n) === "[object Function]";
}
function ai(n) {
  return Mr(n) && Wr(n.pipe);
}
function ui(n) {
  return ke.call(n) === "[object URLSearchParams]";
}
function ci(n) {
  return n.trim ? n.trim() : n.replace(/^\s+|\s+$/g, "");
}
function li() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function Nn(n, e) {
  if (!(n === null || typeof n > "u"))
    if (typeof n != "object" && (n = [n]), kn(n))
      for (var t = 0, r = n.length; t < r; t++)
        e.call(null, n[t], t, n);
    else
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && e.call(null, n[s], s, n);
}
function _n() {
  var n = {};
  function e(s, i) {
    At(n[i]) && At(s) ? n[i] = _n(n[i], s) : At(s) ? n[i] = _n({}, s) : kn(s) ? n[i] = s.slice() : n[i] = s;
  }
  for (var t = 0, r = arguments.length; t < r; t++)
    Nn(arguments[t], e);
  return n;
}
function fi(n, e, t) {
  return Nn(e, function(s, i) {
    t && typeof s == "function" ? n[i] = Qs(s, t) : n[i] = s;
  }), n;
}
function hi(n) {
  return n.charCodeAt(0) === 65279 && (n = n.slice(1)), n;
}
var oe = {
  isArray: kn,
  isArrayBuffer: $r,
  isBuffer: Zs,
  isFormData: ei,
  isArrayBufferView: ti,
  isString: ni,
  isNumber: ri,
  isObject: Mr,
  isPlainObject: At,
  isUndefined: gn,
  isDate: si,
  isFile: ii,
  isBlob: oi,
  isFunction: Wr,
  isStream: ai,
  isURLSearchParams: ui,
  isStandardBrowserEnv: li,
  forEach: Nn,
  merge: _n,
  extend: fi,
  trim: ci,
  stripBOM: hi
}, ze = oe;
function Kn(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var Hr = function(e, t, r) {
  if (!t)
    return e;
  var s;
  if (r)
    s = r(t);
  else if (ze.isURLSearchParams(t))
    s = t.toString();
  else {
    var i = [];
    ze.forEach(t, function(f, a) {
      f === null || typeof f > "u" || (ze.isArray(f) ? a = a + "[]" : f = [f], ze.forEach(f, function(l) {
        ze.isDate(l) ? l = l.toISOString() : ze.isObject(l) && (l = JSON.stringify(l)), i.push(Kn(a) + "=" + Kn(l));
      }));
    }), s = i.join("&");
  }
  if (s) {
    var o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}, di = oe;
function Ft() {
  this.handlers = [];
}
Ft.prototype.use = function(e, t, r) {
  return this.handlers.push({
    fulfilled: e,
    rejected: t,
    synchronous: r ? r.synchronous : !1,
    runWhen: r ? r.runWhen : null
  }), this.handlers.length - 1;
};
Ft.prototype.eject = function(e) {
  this.handlers[e] && (this.handlers[e] = null);
};
Ft.prototype.forEach = function(e) {
  di.forEach(this.handlers, function(r) {
    r !== null && e(r);
  });
};
var pi = Ft, vi = oe, yi = function(e, t) {
  vi.forEach(e, function(s, i) {
    i !== t && i.toUpperCase() === t.toUpperCase() && (e[t] = s, delete e[i]);
  });
}, Yr = function(e, t, r, s, i) {
  return e.config = t, r && (e.code = r), e.request = s, e.response = i, e.isAxiosError = !0, e.toJSON = function() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }, e;
}, Jr = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Jt, Gn;
function zr() {
  if (Gn)
    return Jt;
  Gn = 1;
  var n = Yr;
  return Jt = function(t, r, s, i, o) {
    var c = new Error(t);
    return n(c, r, s, i, o);
  }, Jt;
}
var zt, Xn;
function mi() {
  if (Xn)
    return zt;
  Xn = 1;
  var n = zr();
  return zt = function(t, r, s) {
    var i = s.config.validateStatus;
    !s.status || !i || i(s.status) ? t(s) : r(n(
      "Request failed with status code " + s.status,
      s.config,
      null,
      s.request,
      s
    ));
  }, zt;
}
var Kt, Qn;
function gi() {
  if (Qn)
    return Kt;
  Qn = 1;
  var n = oe;
  return Kt = n.isStandardBrowserEnv() ? function() {
    return {
      write: function(r, s, i, o, c, f) {
        var a = [];
        a.push(r + "=" + encodeURIComponent(s)), n.isNumber(i) && a.push("expires=" + new Date(i).toGMTString()), n.isString(o) && a.push("path=" + o), n.isString(c) && a.push("domain=" + c), f === !0 && a.push("secure"), document.cookie = a.join("; ");
      },
      read: function(r) {
        var s = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
        return s ? decodeURIComponent(s[3]) : null;
      },
      remove: function(r) {
        this.write(r, "", Date.now() - 864e5);
      }
    };
  }() : function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }(), Kt;
}
var Gt, Zn;
function _i() {
  return Zn || (Zn = 1, Gt = function(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  }), Gt;
}
var Xt, er;
function bi() {
  return er || (er = 1, Xt = function(e, t) {
    return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }), Xt;
}
var Qt, tr;
function wi() {
  if (tr)
    return Qt;
  tr = 1;
  var n = _i(), e = bi();
  return Qt = function(r, s) {
    return r && !n(s) ? e(r, s) : s;
  }, Qt;
}
var Zt, nr;
function Ei() {
  if (nr)
    return Zt;
  nr = 1;
  var n = oe, e = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return Zt = function(r) {
    var s = {}, i, o, c;
    return r && n.forEach(r.split(`
`), function(a) {
      if (c = a.indexOf(":"), i = n.trim(a.substr(0, c)).toLowerCase(), o = n.trim(a.substr(c + 1)), i) {
        if (s[i] && e.indexOf(i) >= 0)
          return;
        i === "set-cookie" ? s[i] = (s[i] ? s[i] : []).concat([o]) : s[i] = s[i] ? s[i] + ", " + o : o;
      }
    }), s;
  }, Zt;
}
var en, rr;
function Ri() {
  if (rr)
    return en;
  rr = 1;
  var n = oe;
  return en = n.isStandardBrowserEnv() ? function() {
    var t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a"), s;
    function i(o) {
      var c = o;
      return t && (r.setAttribute("href", c), c = r.href), r.setAttribute("href", c), {
        href: r.href,
        protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
        host: r.host,
        search: r.search ? r.search.replace(/^\?/, "") : "",
        hash: r.hash ? r.hash.replace(/^#/, "") : "",
        hostname: r.hostname,
        port: r.port,
        pathname: r.pathname.charAt(0) === "/" ? r.pathname : "/" + r.pathname
      };
    }
    return s = i(window.location.href), function(c) {
      var f = n.isString(c) ? i(c) : c;
      return f.protocol === s.protocol && f.host === s.host;
    };
  }() : function() {
    return function() {
      return !0;
    };
  }(), en;
}
var tn, sr;
function Bt() {
  if (sr)
    return tn;
  sr = 1;
  function n(e) {
    this.message = e;
  }
  return n.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, n.prototype.__CANCEL__ = !0, tn = n, tn;
}
var nn, ir;
function or() {
  if (ir)
    return nn;
  ir = 1;
  var n = oe, e = mi(), t = gi(), r = Hr, s = wi(), i = Ei(), o = Ri(), c = zr(), f = Jr, a = Bt();
  return nn = function(l) {
    return new Promise(function(v, b) {
      var w = l.data, x = l.headers, g = l.responseType, T;
      function D() {
        l.cancelToken && l.cancelToken.unsubscribe(T), l.signal && l.signal.removeEventListener("abort", T);
      }
      n.isFormData(w) && delete x["Content-Type"];
      var m = new XMLHttpRequest();
      if (l.auth) {
        var V = l.auth.username || "", U = l.auth.password ? unescape(encodeURIComponent(l.auth.password)) : "";
        x.Authorization = "Basic " + btoa(V + ":" + U);
      }
      var L = s(l.baseURL, l.url);
      m.open(l.method.toUpperCase(), r(L, l.params, l.paramsSerializer), !0), m.timeout = l.timeout;
      function E() {
        if (!!m) {
          var k = "getAllResponseHeaders" in m ? i(m.getAllResponseHeaders()) : null, X = !g || g === "text" || g === "json" ? m.responseText : m.response, ne = {
            data: X,
            status: m.status,
            statusText: m.statusText,
            headers: k,
            config: l,
            request: m
          };
          e(function($) {
            v($), D();
          }, function($) {
            b($), D();
          }, ne), m = null;
        }
      }
      if ("onloadend" in m ? m.onloadend = E : m.onreadystatechange = function() {
        !m || m.readyState !== 4 || m.status === 0 && !(m.responseURL && m.responseURL.indexOf("file:") === 0) || setTimeout(E);
      }, m.onabort = function() {
        !m || (b(c("Request aborted", l, "ECONNABORTED", m)), m = null);
      }, m.onerror = function() {
        b(c("Network Error", l, null, m)), m = null;
      }, m.ontimeout = function() {
        var X = l.timeout ? "timeout of " + l.timeout + "ms exceeded" : "timeout exceeded", ne = l.transitional || f;
        l.timeoutErrorMessage && (X = l.timeoutErrorMessage), b(c(
          X,
          l,
          ne.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          m
        )), m = null;
      }, n.isStandardBrowserEnv()) {
        var j = (l.withCredentials || o(L)) && l.xsrfCookieName ? t.read(l.xsrfCookieName) : void 0;
        j && (x[l.xsrfHeaderName] = j);
      }
      "setRequestHeader" in m && n.forEach(x, function(X, ne) {
        typeof w > "u" && ne.toLowerCase() === "content-type" ? delete x[ne] : m.setRequestHeader(ne, X);
      }), n.isUndefined(l.withCredentials) || (m.withCredentials = !!l.withCredentials), g && g !== "json" && (m.responseType = l.responseType), typeof l.onDownloadProgress == "function" && m.addEventListener("progress", l.onDownloadProgress), typeof l.onUploadProgress == "function" && m.upload && m.upload.addEventListener("progress", l.onUploadProgress), (l.cancelToken || l.signal) && (T = function(k) {
        !m || (b(!k || k && k.type ? new a("canceled") : k), m.abort(), m = null);
      }, l.cancelToken && l.cancelToken.subscribe(T), l.signal && (l.signal.aborted ? T() : l.signal.addEventListener("abort", T))), w || (w = null), m.send(w);
    });
  }, nn;
}
var Q = oe, ar = yi, Si = Yr, Ti = Jr, Oi = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function ur(n, e) {
  !Q.isUndefined(n) && Q.isUndefined(n["Content-Type"]) && (n["Content-Type"] = e);
}
function xi() {
  var n;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (n = or()), n;
}
function Ci(n, e, t) {
  if (Q.isString(n))
    try {
      return (e || JSON.parse)(n), Q.trim(n);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (t || JSON.stringify)(n);
}
var It = {
  transitional: Ti,
  adapter: xi(),
  transformRequest: [function(e, t) {
    return ar(t, "Accept"), ar(t, "Content-Type"), Q.isFormData(e) || Q.isArrayBuffer(e) || Q.isBuffer(e) || Q.isStream(e) || Q.isFile(e) || Q.isBlob(e) ? e : Q.isArrayBufferView(e) ? e.buffer : Q.isURLSearchParams(e) ? (ur(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : Q.isObject(e) || t && t["Content-Type"] === "application/json" ? (ur(t, "application/json"), Ci(e)) : e;
  }],
  transformResponse: [function(e) {
    var t = this.transitional || It.transitional, r = t && t.silentJSONParsing, s = t && t.forcedJSONParsing, i = !r && this.responseType === "json";
    if (i || s && Q.isString(e) && e.length)
      try {
        return JSON.parse(e);
      } catch (o) {
        if (i)
          throw o.name === "SyntaxError" ? Si(o, this, "E_JSON_PARSE") : o;
      }
    return e;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
Q.forEach(["delete", "get", "head"], function(e) {
  It.headers[e] = {};
});
Q.forEach(["post", "put", "patch"], function(e) {
  It.headers[e] = Q.merge(Oi);
});
var Pn = It, Ai = oe, Li = Pn, Di = function(e, t, r) {
  var s = this || Li;
  return Ai.forEach(r, function(o) {
    e = o.call(s, e, t);
  }), e;
}, rn, cr;
function Kr() {
  return cr || (cr = 1, rn = function(e) {
    return !!(e && e.__CANCEL__);
  }), rn;
}
var lr = oe, sn = Di, ki = Kr(), Ni = Pn, Pi = Bt();
function on(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new Pi("canceled");
}
var Fi = function(e) {
  on(e), e.headers = e.headers || {}, e.data = sn.call(
    e,
    e.data,
    e.headers,
    e.transformRequest
  ), e.headers = lr.merge(
    e.headers.common || {},
    e.headers[e.method] || {},
    e.headers
  ), lr.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(s) {
      delete e.headers[s];
    }
  );
  var t = e.adapter || Ni.adapter;
  return t(e).then(function(s) {
    return on(e), s.data = sn.call(
      e,
      s.data,
      s.headers,
      e.transformResponse
    ), s;
  }, function(s) {
    return ki(s) || (on(e), s && s.response && (s.response.data = sn.call(
      e,
      s.response.data,
      s.response.headers,
      e.transformResponse
    ))), Promise.reject(s);
  });
}, ae = oe, Gr = function(e, t) {
  t = t || {};
  var r = {};
  function s(h, l) {
    return ae.isPlainObject(h) && ae.isPlainObject(l) ? ae.merge(h, l) : ae.isPlainObject(l) ? ae.merge({}, l) : ae.isArray(l) ? l.slice() : l;
  }
  function i(h) {
    if (ae.isUndefined(t[h])) {
      if (!ae.isUndefined(e[h]))
        return s(void 0, e[h]);
    } else
      return s(e[h], t[h]);
  }
  function o(h) {
    if (!ae.isUndefined(t[h]))
      return s(void 0, t[h]);
  }
  function c(h) {
    if (ae.isUndefined(t[h])) {
      if (!ae.isUndefined(e[h]))
        return s(void 0, e[h]);
    } else
      return s(void 0, t[h]);
  }
  function f(h) {
    if (h in t)
      return s(e[h], t[h]);
    if (h in e)
      return s(void 0, e[h]);
  }
  var a = {
    url: o,
    method: o,
    data: o,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: f
  };
  return ae.forEach(Object.keys(e).concat(Object.keys(t)), function(l) {
    var p = a[l] || i, v = p(l);
    ae.isUndefined(v) && p !== f || (r[l] = v);
  }), r;
}, an, fr;
function Xr() {
  return fr || (fr = 1, an = {
    version: "0.26.1"
  }), an;
}
var Bi = Xr().version, Fn = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(n, e) {
  Fn[n] = function(r) {
    return typeof r === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
var hr = {};
Fn.transitional = function(e, t, r) {
  function s(i, o) {
    return "[Axios v" + Bi + "] Transitional option '" + i + "'" + o + (r ? ". " + r : "");
  }
  return function(i, o, c) {
    if (e === !1)
      throw new Error(s(o, " has been removed" + (t ? " in " + t : "")));
    return t && !hr[o] && (hr[o] = !0, console.warn(
      s(
        o,
        " has been deprecated since v" + t + " and will be removed in the near future"
      )
    )), e ? e(i, o, c) : !0;
  };
};
function Ii(n, e, t) {
  if (typeof n != "object")
    throw new TypeError("options must be an object");
  for (var r = Object.keys(n), s = r.length; s-- > 0; ) {
    var i = r[s], o = e[i];
    if (o) {
      var c = n[i], f = c === void 0 || o(c, i, n);
      if (f !== !0)
        throw new TypeError("option " + i + " must be " + f);
      continue;
    }
    if (t !== !0)
      throw Error("Unknown option " + i);
  }
}
var Ui = {
  assertOptions: Ii,
  validators: Fn
}, Qr = oe, qi = Hr, dr = pi, pr = Fi, Ut = Gr, Zr = Ui, Ke = Zr.validators;
function pt(n) {
  this.defaults = n, this.interceptors = {
    request: new dr(),
    response: new dr()
  };
}
pt.prototype.request = function(e, t) {
  typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Ut(this.defaults, t), t.method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = "get";
  var r = t.transitional;
  r !== void 0 && Zr.assertOptions(r, {
    silentJSONParsing: Ke.transitional(Ke.boolean),
    forcedJSONParsing: Ke.transitional(Ke.boolean),
    clarifyTimeoutError: Ke.transitional(Ke.boolean)
  }, !1);
  var s = [], i = !0;
  this.interceptors.request.forEach(function(v) {
    typeof v.runWhen == "function" && v.runWhen(t) === !1 || (i = i && v.synchronous, s.unshift(v.fulfilled, v.rejected));
  });
  var o = [];
  this.interceptors.response.forEach(function(v) {
    o.push(v.fulfilled, v.rejected);
  });
  var c;
  if (!i) {
    var f = [pr, void 0];
    for (Array.prototype.unshift.apply(f, s), f = f.concat(o), c = Promise.resolve(t); f.length; )
      c = c.then(f.shift(), f.shift());
    return c;
  }
  for (var a = t; s.length; ) {
    var h = s.shift(), l = s.shift();
    try {
      a = h(a);
    } catch (p) {
      l(p);
      break;
    }
  }
  try {
    c = pr(a);
  } catch (p) {
    return Promise.reject(p);
  }
  for (; o.length; )
    c = c.then(o.shift(), o.shift());
  return c;
};
pt.prototype.getUri = function(e) {
  return e = Ut(this.defaults, e), qi(e.url, e.params, e.paramsSerializer).replace(/^\?/, "");
};
Qr.forEach(["delete", "get", "head", "options"], function(e) {
  pt.prototype[e] = function(t, r) {
    return this.request(Ut(r || {}, {
      method: e,
      url: t,
      data: (r || {}).data
    }));
  };
});
Qr.forEach(["post", "put", "patch"], function(e) {
  pt.prototype[e] = function(t, r, s) {
    return this.request(Ut(s || {}, {
      method: e,
      url: t,
      data: r
    }));
  };
});
var Vi = pt, un, vr;
function ji() {
  if (vr)
    return un;
  vr = 1;
  var n = Bt();
  function e(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    var r;
    this.promise = new Promise(function(o) {
      r = o;
    });
    var s = this;
    this.promise.then(function(i) {
      if (!!s._listeners) {
        var o, c = s._listeners.length;
        for (o = 0; o < c; o++)
          s._listeners[o](i);
        s._listeners = null;
      }
    }), this.promise.then = function(i) {
      var o, c = new Promise(function(f) {
        s.subscribe(f), o = f;
      }).then(i);
      return c.cancel = function() {
        s.unsubscribe(o);
      }, c;
    }, t(function(o) {
      s.reason || (s.reason = new n(o), r(s.reason));
    });
  }
  return e.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, e.prototype.subscribe = function(r) {
    if (this.reason) {
      r(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(r) : this._listeners = [r];
  }, e.prototype.unsubscribe = function(r) {
    if (!!this._listeners) {
      var s = this._listeners.indexOf(r);
      s !== -1 && this._listeners.splice(s, 1);
    }
  }, e.source = function() {
    var r, s = new e(function(o) {
      r = o;
    });
    return {
      token: s,
      cancel: r
    };
  }, un = e, un;
}
var cn, yr;
function $i() {
  return yr || (yr = 1, cn = function(e) {
    return function(r) {
      return e.apply(null, r);
    };
  }), cn;
}
var ln, mr;
function Mi() {
  if (mr)
    return ln;
  mr = 1;
  var n = oe;
  return ln = function(t) {
    return n.isObject(t) && t.isAxiosError === !0;
  }, ln;
}
var gr = oe, Wi = jr, Lt = Vi, Hi = Gr, Yi = Pn;
function es(n) {
  var e = new Lt(n), t = Wi(Lt.prototype.request, e);
  return gr.extend(t, Lt.prototype, e), gr.extend(t, e), t.create = function(s) {
    return es(Hi(n, s));
  }, t;
}
var ge = es(Yi);
ge.Axios = Lt;
ge.Cancel = Bt();
ge.CancelToken = ji();
ge.isCancel = Kr();
ge.VERSION = Xr().version;
ge.all = function(e) {
  return Promise.all(e);
};
ge.spread = $i();
ge.isAxiosError = Mi();
Dn.exports = ge;
Dn.exports.default = ge;
(function(n) {
  n.exports = Dn.exports;
})(Vr);
Object.defineProperty(Ge, "__esModule", { value: !0 });
Ge.getRequestHeaders = Ge.getAxiosClient = void 0;
var Ji = Vr.exports;
function zi(n, e, t, r) {
  return Ji.default.create({
    baseURL: n,
    headers: ts(e, r, t),
    withCredentials: !0
  });
}
Ge.getAxiosClient = zi;
function ts(n, e, t) {
  n === void 0 && (n = !1);
  var r = {
    Accept: "application/json",
    "Content-Type": "application/json; charset=utf-8"
  };
  return n && e && t && (r.Authorization = "".concat(e, " ").concat(t())), typeof window < "u" && typeof document < "u" && (window.location && (r["X-Frappe-Site-Name"] = window.location.hostname), window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (r["X-Frappe-CSRF-Token"] = window.csrf_token)), r;
}
Ge.getRequestHeaders = ts;
var _r;
function Ki() {
  if (_r)
    return rt;
  _r = 1, Object.defineProperty(rt, "__esModule", { value: !0 }), rt.FrappeApp = void 0;
  var n = ns(), e = ft, t = ht, r = dt, s = Ge, i = function() {
    function o(c, f, a) {
      var h, l;
      this.url = c, this.name = a != null ? a : "FrappeApp", this.useToken = (h = f == null ? void 0 : f.useToken) !== null && h !== void 0 ? h : !1, this.token = f == null ? void 0 : f.token, this.tokenType = (l = f == null ? void 0 : f.type) !== null && l !== void 0 ? l : "Bearer", this.axios = (0, s.getAxiosClient)(this.url, this.useToken, this.token, this.tokenType);
    }
    return o.prototype.auth = function() {
      return new n.FrappeAuth(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.db = function() {
      return new t.FrappeDB(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.file = function() {
      return new r.FrappeFileUpload(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o.prototype.call = function() {
      return new e.FrappeCall(this.url, this.axios, this.useToken, this.token, this.tokenType);
    }, o;
  }();
  return rt.FrappeApp = i, rt;
}
var qt = {}, ve = F && F.__assign || function() {
  return ve = Object.assign || function(n) {
    for (var e, t = 1, r = arguments.length; t < r; t++) {
      e = arguments[t];
      for (var s in e)
        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);
    }
    return n;
  }, ve.apply(this, arguments);
}, Rt = F && F.__awaiter || function(n, e, t, r) {
  function s(i) {
    return i instanceof t ? i : new t(function(o) {
      o(i);
    });
  }
  return new (t || (t = Promise))(function(i, o) {
    function c(h) {
      try {
        a(r.next(h));
      } catch (l) {
        o(l);
      }
    }
    function f(h) {
      try {
        a(r.throw(h));
      } catch (l) {
        o(l);
      }
    }
    function a(h) {
      h.done ? i(h.value) : s(h.value).then(c, f);
    }
    a((r = r.apply(n, e || [])).next());
  });
}, St = F && F.__generator || function(n, e) {
  var t = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, s, i, o;
  return o = { next: c(0), throw: c(1), return: c(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function c(a) {
    return function(h) {
      return f([a, h]);
    };
  }
  function f(a) {
    if (r)
      throw new TypeError("Generator is already executing.");
    for (; t; )
      try {
        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)
          return i;
        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {
          case 0:
          case 1:
            i = a;
            break;
          case 4:
            return t.label++, { value: a[1], done: !1 };
          case 5:
            t.label++, s = a[1], a = [0];
            continue;
          case 7:
            a = t.ops.pop(), t.trys.pop();
            continue;
          default:
            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {
              t = 0;
              continue;
            }
            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {
              t.label = a[1];
              break;
            }
            if (a[0] === 6 && t.label < i[1]) {
              t.label = i[1], i = a;
              break;
            }
            if (i && t.label < i[2]) {
              t.label = i[2], t.ops.push(a);
              break;
            }
            i[2] && t.ops.pop(), t.trys.pop();
            continue;
        }
        a = e.call(n, t);
      } catch (h) {
        a = [6, h], s = 0;
      } finally {
        r = i = 0;
      }
    if (a[0] & 5)
      throw a[1];
    return { value: a[0] ? a[1] : void 0, done: !0 };
  }
};
Object.defineProperty(qt, "__esModule", { value: !0 });
qt.FrappeAuth = void 0;
var Gi = function() {
  function n(e, t, r, s, i) {
    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;
  }
  return n.prototype.loginWithUsernamePassword = function(e) {
    return Rt(this, void 0, void 0, function() {
      var t, r, s;
      return St(this, function(i) {
        return t = e.username, r = e.password, s = e.device, [2, this.axios.post("/api/method/login", {
          usr: t,
          pwd: r,
          device: s
        }).then(function(o) {
          return o.data;
        }).catch(function(o) {
          var c, f;
          throw ve(ve({}, o.response.data), { httpStatus: o.response.status, httpStatusText: o.response.statusText, message: (c = o.response.data.message) !== null && c !== void 0 ? c : "There was an error while logging in", exception: (f = o.response.data.exception) !== null && f !== void 0 ? f : "" });
        })];
      });
    });
  }, n.prototype.getLoggedInUser = function() {
    return Rt(this, void 0, void 0, function() {
      return St(this, function(e) {
        return [2, this.axios.get("/api/method/frappe.auth.get_logged_user").then(function(t) {
          return t.data.message;
        }).catch(function(t) {
          var r;
          throw ve(ve({}, t.response.data), { httpStatus: t.response.status, httpStatusText: t.response.statusText, message: "There was an error while fetching the logged in user", exception: (r = t.response.data.exception) !== null && r !== void 0 ? r : "" });
        })];
      });
    });
  }, n.prototype.logout = function() {
    return Rt(this, void 0, void 0, function() {
      return St(this, function(e) {
        return [2, this.axios.post("/api/method/logout", {}).then(function() {
        }).catch(function(t) {
          var r, s;
          throw ve(ve({}, t.response.data), { httpStatus: t.response.status, httpStatusText: t.response.statusText, message: (r = t.response.data.message) !== null && r !== void 0 ? r : "There was an error while logging out", exception: (s = t.response.data.exception) !== null && s !== void 0 ? s : "" });
        })];
      });
    });
  }, n.prototype.forgetPassword = function(e) {
    return Rt(this, void 0, void 0, function() {
      return St(this, function(t) {
        return [2, this.axios.post("/", {
          cmd: "frappe.core.doctype.user.user.reset_password",
          user: e
        }).then(function() {
        }).catch(function(r) {
          var s, i;
          throw ve(ve({}, r.response.data), { httpStatus: r.response.status, httpStatusText: r.response.statusText, message: (s = r.response.data.message) !== null && s !== void 0 ? s : "There was an error sending password reset email.", exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : "" });
        })];
      });
    });
  }, n;
}();
qt.FrappeAuth = Gi;
var br;
function ns() {
  return br || (br = 1, function(n) {
    var e = F && F.__createBinding || (Object.create ? function(r, s, i, o) {
      o === void 0 && (o = i);
      var c = Object.getOwnPropertyDescriptor(s, i);
      (!c || ("get" in c ? !s.__esModule : c.writable || c.configurable)) && (c = { enumerable: !0, get: function() {
        return s[i];
      } }), Object.defineProperty(r, o, c);
    } : function(r, s, i, o) {
      o === void 0 && (o = i), r[o] = s[i];
    }), t = F && F.__exportStar || function(r, s) {
      for (var i in r)
        i !== "default" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);
    };
    Object.defineProperty(n, "__esModule", { value: !0 }), t(Ki(), n), t(qt, n), t(ht, n), t(dt, n), t(ft, n);
  }(Yt)), Yt;
}
var Xi = ns(), rs = { exports: {} }, fn = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wr;
function Qi() {
  if (wr)
    return fn;
  wr = 1;
  var n = qe;
  function e(l, p) {
    return l === p && (l !== 0 || 1 / l === 1 / p) || l !== l && p !== p;
  }
  var t = typeof Object.is == "function" ? Object.is : e, r = n.useState, s = n.useEffect, i = n.useLayoutEffect, o = n.useDebugValue;
  function c(l, p) {
    var v = p(), b = r({ inst: { value: v, getSnapshot: p } }), w = b[0].inst, x = b[1];
    return i(function() {
      w.value = v, w.getSnapshot = p, f(w) && x({ inst: w });
    }, [l, v, p]), s(function() {
      return f(w) && x({ inst: w }), l(function() {
        f(w) && x({ inst: w });
      });
    }, [l]), o(v), v;
  }
  function f(l) {
    var p = l.getSnapshot;
    l = l.value;
    try {
      var v = p();
      return !t(l, v);
    } catch {
      return !0;
    }
  }
  function a(l, p) {
    return p();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? a : c;
  return fn.useSyncExternalStore = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : h, fn;
}
var hn = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Er;
function Zi() {
  return Er || (Er = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var n = qe, e = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function t(D) {
      {
        for (var m = arguments.length, V = new Array(m > 1 ? m - 1 : 0), U = 1; U < m; U++)
          V[U - 1] = arguments[U];
        r("error", D, V);
      }
    }
    function r(D, m, V) {
      {
        var U = e.ReactDebugCurrentFrame, L = U.getStackAddendum();
        L !== "" && (m += "%s", V = V.concat([L]));
        var E = V.map(function(j) {
          return String(j);
        });
        E.unshift("Warning: " + m), Function.prototype.apply.call(console[D], console, E);
      }
    }
    function s(D, m) {
      return D === m && (D !== 0 || 1 / D === 1 / m) || D !== D && m !== m;
    }
    var i = typeof Object.is == "function" ? Object.is : s, o = n.useState, c = n.useEffect, f = n.useLayoutEffect, a = n.useDebugValue, h = !1, l = !1;
    function p(D, m, V) {
      h || n.startTransition !== void 0 && (h = !0, t("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var U = m();
      if (!l) {
        var L = m();
        i(U, L) || (t("The result of getSnapshot should be cached to avoid an infinite loop"), l = !0);
      }
      var E = o({
        inst: {
          value: U,
          getSnapshot: m
        }
      }), j = E[0].inst, k = E[1];
      return f(function() {
        j.value = U, j.getSnapshot = m, v(j) && k({
          inst: j
        });
      }, [D, U, m]), c(function() {
        v(j) && k({
          inst: j
        });
        var X = function() {
          v(j) && k({
            inst: j
          });
        };
        return D(X);
      }, [D]), a(U), U;
    }
    function v(D) {
      var m = D.getSnapshot, V = D.value;
      try {
        var U = m();
        return !i(V, U);
      } catch {
        return !0;
      }
    }
    function b(D, m, V) {
      return m();
    }
    var w = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", x = !w, g = x ? b : p, T = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : g;
    hn.useSyncExternalStore = T, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), hn;
}
(function(n) {
  process.env.NODE_ENV === "production" ? n.exports = Qi() : n.exports = Zi();
})(rs);
const Ae = () => {
}, fe = Ae(), dn = Object, C = (n) => n === fe, xe = (n) => typeof n == "function", De = (n, e) => ({
  ...n,
  ...e
}), eo = (n) => xe(n.then), Tt = /* @__PURE__ */ new WeakMap();
let to = 0;
const ct = (n) => {
  const e = typeof n, t = n && n.constructor, r = t == Date;
  let s, i;
  if (dn(n) === n && !r && t != RegExp) {
    if (s = Tt.get(n), s)
      return s;
    if (s = ++to + "~", Tt.set(n, s), t == Array) {
      for (s = "@", i = 0; i < n.length; i++)
        s += ct(n[i]) + ",";
      Tt.set(n, s);
    }
    if (t == dn) {
      s = "#";
      const o = dn.keys(n).sort();
      for (; !C(i = o.pop()); )
        C(n[i]) || (s += i + ":" + ct(n[i]) + ",");
      Tt.set(n, s);
    }
  } else
    s = r ? n.toJSON() : e == "symbol" ? n.toString() : e == "string" ? JSON.stringify(n) : "" + n;
  return s;
}, Oe = /* @__PURE__ */ new WeakMap(), pn = {}, Ot = {}, Bn = "undefined", Vt = typeof window != Bn, bn = typeof document != Bn, no = () => Vt && typeof window.requestAnimationFrame != Bn, ss = (n, e) => {
  const t = Oe.get(n);
  return [
    () => !C(e) && n.get(e) || pn,
    (r) => {
      if (!C(e)) {
        const s = n.get(e);
        e in Ot || (Ot[e] = s), t[5](e, De(s, r), s || pn);
      }
    },
    t[6],
    () => !C(e) && e in Ot ? Ot[e] : !C(e) && n.get(e) || pn
  ];
};
let wn = !0;
const ro = () => wn, [En, Rn] = Vt && window.addEventListener ? [
  window.addEventListener.bind(window),
  window.removeEventListener.bind(window)
] : [
  Ae,
  Ae
], so = () => {
  const n = bn && document.visibilityState;
  return C(n) || n !== "hidden";
}, io = (n) => (bn && document.addEventListener("visibilitychange", n), En("focus", n), () => {
  bn && document.removeEventListener("visibilitychange", n), Rn("focus", n);
}), oo = (n) => {
  const e = () => {
    wn = !0, n();
  }, t = () => {
    wn = !1;
  };
  return En("online", e), En("offline", t), () => {
    Rn("online", e), Rn("offline", t);
  };
}, ao = {
  isOnline: ro,
  isVisible: so
}, uo = {
  initFocus: io,
  initReconnect: oo
}, Rr = !qe.useId, lt = !Vt || "Deno" in window, co = (n) => no() ? window.requestAnimationFrame(n) : setTimeout(n, 1), vn = lt ? Xe : Hs, yn = typeof navigator < "u" && navigator.connection, Sr = !lt && yn && ([
  "slow-2g",
  "2g"
].includes(yn.effectiveType) || yn.saveData), In = (n) => {
  if (xe(n))
    try {
      n = n();
    } catch {
      n = "";
    }
  const e = n;
  return n = typeof n == "string" ? n : (Array.isArray(n) ? n.length : n) ? ct(n) : "", [
    n,
    e
  ];
};
let lo = 0;
const Sn = () => ++lo, is = 0, os = 1, as = 2, fo = 3;
var st = {
  __proto__: null,
  ERROR_REVALIDATE_EVENT: fo,
  FOCUS_EVENT: is,
  MUTATE_EVENT: as,
  RECONNECT_EVENT: os
};
async function us(...n) {
  const [e, t, r, s] = n, i = De({
    populateCache: !0,
    throwOnError: !0
  }, typeof s == "boolean" ? {
    revalidate: s
  } : s || {});
  let o = i.populateCache;
  const c = i.rollbackOnError;
  let f = i.optimisticData;
  const a = i.revalidate !== !1, h = (v) => typeof c == "function" ? c(v) : c !== !1, l = i.throwOnError;
  if (xe(t)) {
    const v = t, b = [], w = e.keys();
    for (const x of w)
      !/^\$(inf|sub)\$/.test(x) && v(e.get(x)._k) && b.push(x);
    return Promise.all(b.map(p));
  }
  return p(t);
  async function p(v) {
    const [b] = In(v);
    if (!b)
      return;
    const [w, x] = ss(e, b), [g, T, D, m] = Oe.get(e), V = g[b], U = () => a && (delete D[b], delete m[b], V && V[0]) ? V[0](as).then(() => w().data) : w().data;
    if (n.length < 3)
      return U();
    let L = r, E;
    const j = Sn();
    T[b] = [
      j,
      0
    ];
    const k = !C(f), X = w(), ne = X.data, Z = X._c, $ = C(Z) ? ne : Z;
    if (k && (f = xe(f) ? f($, ne) : f, x({
      data: f,
      _c: $
    })), xe(L))
      try {
        L = L($);
      } catch (be) {
        E = be;
      }
    if (L && eo(L))
      if (L = await L.catch((be) => {
        E = be;
      }), j !== T[b][0]) {
        if (E)
          throw E;
        return L;
      } else
        E && k && h(E) && (o = !0, L = $, x({
          data: L,
          _c: fe
        }));
    o && (E || (xe(o) && (L = o(L, $)), x({
      data: L,
      error: fe,
      _c: fe
    }))), T[b][1] = Sn();
    const _e = await U();
    if (x({
      _c: fe
    }), E) {
      if (l)
        throw E;
      return;
    }
    return o ? _e : L;
  }
}
const Tr = (n, e) => {
  for (const t in n)
    n[t][0] && n[t][0](e);
}, ho = (n, e) => {
  if (!Oe.has(n)) {
    const t = De(uo, e), r = {}, s = us.bind(fe, n);
    let i = Ae;
    const o = {}, c = (h, l) => {
      const p = o[h] || [];
      return o[h] = p, p.push(l), () => p.splice(p.indexOf(l), 1);
    }, f = (h, l, p) => {
      n.set(h, l);
      const v = o[h];
      if (v)
        for (const b of v)
          b(l, p);
    }, a = () => {
      if (!Oe.has(n) && (Oe.set(n, [
        r,
        {},
        {},
        {},
        s,
        f,
        c
      ]), !lt)) {
        const h = t.initFocus(setTimeout.bind(fe, Tr.bind(fe, r, is))), l = t.initReconnect(setTimeout.bind(fe, Tr.bind(fe, r, os)));
        i = () => {
          h && h(), l && l(), Oe.delete(n);
        };
      }
    };
    return a(), [
      n,
      s,
      a,
      i
    ];
  }
  return [
    n,
    Oe.get(n)[4]
  ];
}, po = (n, e, t, r, s) => {
  const i = t.errorRetryCount, o = s.retryCount, c = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * t.errorRetryInterval;
  !C(i) && o > i || setTimeout(r, c, s);
}, vo = (n, e) => ct(n) == ct(e), [cs, yo] = ho(/* @__PURE__ */ new Map()), mo = De(
  {
    onLoadingSlow: Ae,
    onSuccess: Ae,
    onError: Ae,
    onErrorRetry: po,
    onDiscarded: Ae,
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    errorRetryInterval: Sr ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: Sr ? 5e3 : 3e3,
    compare: vo,
    isPaused: () => !1,
    cache: cs,
    mutate: yo,
    fallback: {}
  },
  ao
), go = (n, e) => {
  const t = De(n, e);
  if (e) {
    const { use: r, fallback: s } = n, { use: i, fallback: o } = e;
    r && i && (t.use = r.concat(i)), s && o && (t.fallback = De(s, o));
  }
  return t;
}, _o = Ur({}), ls = Vt && window.__SWR_DEVTOOLS_USE__, bo = ls ? window.__SWR_DEVTOOLS_USE__ : [], wo = () => {
  ls && (window.__SWR_DEVTOOLS_REACT__ = qe);
}, Eo = (n) => xe(n[1]) ? [
  n[0],
  n[1],
  n[2] || {}
] : [
  n[0],
  null,
  (n[1] === null ? n[2] : n[1]) || {}
], Ro = () => De(mo, ee(_o)), So = (n) => (e, t, r) => n(e, t && ((...i) => {
  const [o] = In(e), [, , , c] = Oe.get(cs), f = c[o];
  return C(f) ? t(...i) : (delete c[o], f);
}), r), To = bo.concat(So), Oo = (n) => function(...t) {
  const r = Ro(), [s, i, o] = Eo(t), c = go(r, o);
  let f = n;
  const { use: a } = c, h = (a || []).concat(To);
  for (let l = h.length; l--; )
    f = h[l](f);
  return f(s, i || c.fetcher || null, c);
}, xo = (n, e, t) => {
  const r = e[n] || (e[n] = []);
  return r.push(t), () => {
    const s = r.indexOf(t);
    s >= 0 && (r[s] = r[r.length - 1], r.pop());
  };
};
wo();
const Or = qe.use || ((n) => {
  if (n.status === "pending")
    throw n;
  if (n.status === "fulfilled")
    return n.value;
  throw n.status === "rejected" ? n.reason : (n.status = "pending", n.then((e) => {
    n.status = "fulfilled", n.value = e;
  }, (e) => {
    n.status = "rejected", n.reason = e;
  }), n);
}), mn = {
  dedupe: !0
}, Co = (n, e, t) => {
  const { cache: r, compare: s, suspense: i, fallbackData: o, revalidateOnMount: c, revalidateIfStale: f, refreshInterval: a, refreshWhenHidden: h, refreshWhenOffline: l, keepPreviousData: p } = t, [v, b, w, x] = Oe.get(r), [g, T] = In(n), D = Be(!1), m = Be(!1), V = Be(g), U = Be(e), L = Be(t), E = () => L.current, j = () => E().isVisible() && E().isOnline(), [k, X, ne, Z] = ss(r, g), $ = Be({}).current, _e = C(o) ? t.fallback[g] : o, be = (N, B) => {
    for (const G in $) {
      const q = G;
      if (q === "data") {
        if (!s(N[q], B[q]) && (!C(N[q]) || !s(Ve, B[q])))
          return !1;
      } else if (B[q] !== N[q])
        return !1;
    }
    return !0;
  }, Ze = qr(() => {
    const N = (() => !g || !e ? !1 : C(c) ? E().isPaused() || i ? !1 : C(f) ? !0 : f : c)(), B = (Y) => {
      const he = De(Y);
      return delete he._k, N ? {
        isValidating: !0,
        isLoading: !0,
        ...he
      } : he;
    }, G = k(), q = Z(), re = B(G), Se = G === q ? re : B(q);
    let H = re;
    return [
      () => {
        const Y = B(k());
        return be(Y, H) ? (H.data = Y.data, H.isLoading = Y.isLoading, H.isValidating = Y.isValidating, H.error = Y.error, H) : (H = Y, Y);
      },
      () => Se
    ];
  }, [
    r,
    g
  ]), we = rs.exports.useSyncExternalStore(M(
    (N) => ne(g, (B, G) => {
      be(G, B) || N();
    }),
    [
      r,
      g
    ]
  ), Ze[0], Ze[1]), et = !D.current, yt = v[g] && v[g].length > 0, Ee = we.data, Re = C(Ee) ? _e : Ee, Ne = we.error, mt = Be(Re), Ve = p ? C(Ee) ? mt.current : Ee : Re, je = (() => yt && !C(Ne) ? !1 : et && !C(c) ? c : E().isPaused() ? !1 : i ? C(Re) ? !1 : f : C(Re) || f)(), $e = !!(g && e && et && je), Me = C(we.isValidating) ? $e : we.isValidating, tt = C(we.isLoading) ? $e : we.isLoading, pe = M(
    async (N) => {
      const B = U.current;
      if (!g || !B || m.current || E().isPaused())
        return !1;
      let G, q, re = !0;
      const Se = N || {}, H = !w[g] || !Se.dedupe, Y = () => Rr ? !m.current && g === V.current && D.current : g === V.current, he = {
        isValidating: !1,
        isLoading: !1
      }, _t = () => {
        X(he);
      }, We = () => {
        const ie = w[g];
        ie && ie[1] === q && delete w[g];
      }, bt = {
        isValidating: !0
      };
      C(k().data) && (bt.isLoading = !0);
      try {
        if (H && (X(bt), t.loadingTimeout && C(k().data) && setTimeout(() => {
          re && Y() && E().onLoadingSlow(g, t);
        }, t.loadingTimeout), w[g] = [
          B(T),
          Sn()
        ]), [G, q] = w[g], G = await G, H && setTimeout(We, t.dedupingInterval), !w[g] || w[g][1] !== q)
          return H && Y() && E().onDiscarded(g), !1;
        he.error = fe;
        const ie = b[g];
        if (!C(ie) && (q <= ie[0] || q <= ie[1] || ie[1] === 0))
          return _t(), H && Y() && E().onDiscarded(g), !1;
        const ue = k().data;
        he.data = s(ue, G) ? ue : G, H && Y() && E().onSuccess(G, g, t);
      } catch (ie) {
        We();
        const ue = E(), { shouldRetryOnError: He } = ue;
        ue.isPaused() || (he.error = ie, H && Y() && (ue.onError(ie, g, ue), (He === !0 || xe(He) && He(ie)) && j() && ue.onErrorRetry(ie, g, ue, (Pe) => {
          const nt = v[g];
          nt && nt[0] && nt[0](st.ERROR_REVALIDATE_EVENT, Pe);
        }, {
          retryCount: (Se.retryCount || 0) + 1,
          dedupe: !0
        })));
      }
      return re = !1, _t(), !0;
    },
    [
      g,
      r
    ]
  ), gt = M(
    (...N) => us(r, V.current, ...N),
    []
  );
  if (vn(() => {
    U.current = e, L.current = t, C(Ee) || (mt.current = Ee);
  }), vn(() => {
    if (!g)
      return;
    const N = pe.bind(fe, mn);
    let B = 0;
    const q = xo(g, v, (re, Se = {}) => {
      if (re == st.FOCUS_EVENT) {
        const H = Date.now();
        E().revalidateOnFocus && H > B && j() && (B = H + E().focusThrottleInterval, N());
      } else if (re == st.RECONNECT_EVENT)
        E().revalidateOnReconnect && j() && N();
      else {
        if (re == st.MUTATE_EVENT)
          return pe();
        if (re == st.ERROR_REVALIDATE_EVENT)
          return pe(Se);
      }
    });
    return m.current = !1, V.current = g, D.current = !0, X({
      _k: T
    }), je && (C(Re) || lt ? N() : co(N)), () => {
      m.current = !0, q();
    };
  }, [
    g
  ]), vn(() => {
    let N;
    function B() {
      const q = xe(a) ? a(k().data) : a;
      q && N !== -1 && (N = setTimeout(G, q));
    }
    function G() {
      !k().error && (h || E().isVisible()) && (l || E().isOnline()) ? pe(mn).then(B) : B();
    }
    return B(), () => {
      N && (clearTimeout(N), N = -1);
    };
  }, [
    a,
    h,
    l,
    g
  ]), Ys(Ve), i && C(Re) && g) {
    if (!Rr && lt)
      throw new Error("Fallback data is required when using suspense in SSR.");
    U.current = e, L.current = t, m.current = !1;
    const N = x[g];
    if (!C(N)) {
      const B = gt(N);
      Or(B);
    }
    if (C(Ne)) {
      const B = pe(mn);
      C(Ve) || (B.status = "fulfilled", B.value = !0), Or(B);
    } else
      throw Ne;
  }
  return {
    mutate: gt,
    get data() {
      return $.data = !0, Ve;
    },
    get error() {
      return $.error = !0, Ne;
    },
    get isValidating() {
      return $.isValidating = !0, Me;
    },
    get isLoading() {
      return $.isLoading = !0, tt;
    }
  };
}, vt = Oo(Co), me = /* @__PURE__ */ Object.create(null);
me.open = "0";
me.close = "1";
me.ping = "2";
me.pong = "3";
me.message = "4";
me.upgrade = "5";
me.noop = "6";
const Dt = /* @__PURE__ */ Object.create(null);
Object.keys(me).forEach((n) => {
  Dt[me[n]] = n;
});
const Ao = { type: "error", data: "parser error" }, Lo = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Do = typeof ArrayBuffer == "function", ko = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, fs = ({ type: n, data: e }, t, r) => Lo && e instanceof Blob ? t ? r(e) : xr(e, r) : Do && (e instanceof ArrayBuffer || ko(e)) ? t ? r(e) : xr(new Blob([e]), r) : r(me[n] + (e || "")), xr = (n, e) => {
  const t = new FileReader();
  return t.onload = function() {
    const r = t.result.split(",")[1];
    e("b" + (r || ""));
  }, t.readAsDataURL(n);
}, Cr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ut = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let n = 0; n < Cr.length; n++)
  ut[Cr.charCodeAt(n)] = n;
const No = (n) => {
  let e = n.length * 0.75, t = n.length, r, s = 0, i, o, c, f;
  n[n.length - 1] === "=" && (e--, n[n.length - 2] === "=" && e--);
  const a = new ArrayBuffer(e), h = new Uint8Array(a);
  for (r = 0; r < t; r += 4)
    i = ut[n.charCodeAt(r)], o = ut[n.charCodeAt(r + 1)], c = ut[n.charCodeAt(r + 2)], f = ut[n.charCodeAt(r + 3)], h[s++] = i << 2 | o >> 4, h[s++] = (o & 15) << 4 | c >> 2, h[s++] = (c & 3) << 6 | f & 63;
  return a;
}, Po = typeof ArrayBuffer == "function", hs = (n, e) => {
  if (typeof n != "string")
    return {
      type: "message",
      data: ds(n, e)
    };
  const t = n.charAt(0);
  return t === "b" ? {
    type: "message",
    data: Fo(n.substring(1), e)
  } : Dt[t] ? n.length > 1 ? {
    type: Dt[t],
    data: n.substring(1)
  } : {
    type: Dt[t]
  } : Ao;
}, Fo = (n, e) => {
  if (Po) {
    const t = No(n);
    return ds(t, e);
  } else
    return { base64: !0, data: n };
}, ds = (n, e) => {
  switch (e) {
    case "blob":
      return n instanceof ArrayBuffer ? new Blob([n]) : n;
    case "arraybuffer":
    default:
      return n;
  }
}, ps = String.fromCharCode(30), Bo = (n, e) => {
  const t = n.length, r = new Array(t);
  let s = 0;
  n.forEach((i, o) => {
    fs(i, !1, (c) => {
      r[o] = c, ++s === t && e(r.join(ps));
    });
  });
}, Io = (n, e) => {
  const t = n.split(ps), r = [];
  for (let s = 0; s < t.length; s++) {
    const i = hs(t[s], e);
    if (r.push(i), i.type === "error")
      break;
  }
  return r;
}, vs = 4;
function K(n) {
  if (n)
    return Uo(n);
}
function Uo(n) {
  for (var e in K.prototype)
    n[e] = K.prototype[e];
  return n;
}
K.prototype.on = K.prototype.addEventListener = function(n, e) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(e), this;
};
K.prototype.once = function(n, e) {
  function t() {
    this.off(n, t), e.apply(this, arguments);
  }
  return t.fn = e, this.on(n, t), this;
};
K.prototype.off = K.prototype.removeListener = K.prototype.removeAllListeners = K.prototype.removeEventListener = function(n, e) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var t = this._callbacks["$" + n];
  if (!t)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + n], this;
  for (var r, s = 0; s < t.length; s++)
    if (r = t[s], r === e || r.fn === e) {
      t.splice(s, 1);
      break;
    }
  return t.length === 0 && delete this._callbacks["$" + n], this;
};
K.prototype.emit = function(n) {
  this._callbacks = this._callbacks || {};
  for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + n], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  if (t) {
    t = t.slice(0);
    for (var r = 0, s = t.length; r < s; ++r)
      t[r].apply(this, e);
  }
  return this;
};
K.prototype.emitReserved = K.prototype.emit;
K.prototype.listeners = function(n) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [];
};
K.prototype.hasListeners = function(n) {
  return !!this.listeners(n).length;
};
const Le = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
function ys(n, ...e) {
  return e.reduce((t, r) => (n.hasOwnProperty(r) && (t[r] = n[r]), t), {});
}
const qo = setTimeout, Vo = clearTimeout;
function jt(n, e) {
  e.useNativeTimers ? (n.setTimeoutFn = qo.bind(Le), n.clearTimeoutFn = Vo.bind(Le)) : (n.setTimeoutFn = setTimeout.bind(Le), n.clearTimeoutFn = clearTimeout.bind(Le));
}
const jo = 1.33;
function $o(n) {
  return typeof n == "string" ? Mo(n) : Math.ceil((n.byteLength || n.size) * jo);
}
function Mo(n) {
  let e = 0, t = 0;
  for (let r = 0, s = n.length; r < s; r++)
    e = n.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4);
  return t;
}
class Wo extends Error {
  constructor(e, t, r) {
    super(e), this.description = t, this.context = r, this.type = "TransportError";
  }
}
class ms extends K {
  constructor(e) {
    super(), this.writable = !1, jt(this, e), this.opts = e, this.query = e.query, this.readyState = "", this.socket = e.socket;
  }
  onError(e, t, r) {
    return super.emitReserved("error", new Wo(e, t, r)), this;
  }
  open() {
    return (this.readyState === "closed" || this.readyState === "") && (this.readyState = "opening", this.doOpen()), this;
  }
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  send(e) {
    this.readyState === "open" && this.write(e);
  }
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  onData(e) {
    const t = hs(e, this.socket.binaryType);
    this.onPacket(t);
  }
  onPacket(e) {
    super.emitReserved("packet", e);
  }
  onClose(e) {
    this.readyState = "closed", super.emitReserved("close", e);
  }
}
const gs = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), Tn = 64, Ho = {};
let Ar = 0, xt = 0, Lr;
function Dr(n) {
  let e = "";
  do
    e = gs[n % Tn] + e, n = Math.floor(n / Tn);
  while (n > 0);
  return e;
}
function _s() {
  const n = Dr(+new Date());
  return n !== Lr ? (Ar = 0, Lr = n) : n + "." + Dr(Ar++);
}
for (; xt < Tn; xt++)
  Ho[gs[xt]] = xt;
function bs(n) {
  let e = "";
  for (let t in n)
    n.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(n[t]));
  return e;
}
function Yo(n) {
  let e = {}, t = n.split("&");
  for (let r = 0, s = t.length; r < s; r++) {
    let i = t[r].split("=");
    e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);
  }
  return e;
}
let ws = !1;
try {
  ws = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
const Jo = ws;
function Es(n) {
  const e = n.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!e || Jo))
      return new XMLHttpRequest();
  } catch {
  }
  if (!e)
    try {
      return new Le[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
function zo() {
}
const Ko = function() {
  return new Es({
    xdomain: !1
  }).responseType != null;
}();
class Go extends ms {
  constructor(e) {
    if (super(e), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let s = location.port;
      s || (s = r ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || s !== e.port, this.xs = e.secure !== r;
    }
    const t = e && e.forceBase64;
    this.supportsBinary = Ko && !t;
  }
  get name() {
    return "polling";
  }
  doOpen() {
    this.poll();
  }
  pause(e) {
    this.readyState = "pausing";
    const t = () => {
      this.readyState = "paused", e();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (r++, this.once("pollComplete", function() {
        --r || t();
      })), this.writable || (r++, this.once("drain", function() {
        --r || t();
      }));
    } else
      t();
  }
  poll() {
    this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  onData(e) {
    const t = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    Io(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this.poll());
  }
  doClose() {
    const e = () => {
      this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? e() : this.once("open", e);
  }
  write(e) {
    this.writable = !1, Bo(e, (t) => {
      this.doWrite(t, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  uri() {
    let e = this.query || {};
    const t = this.opts.secure ? "https" : "http";
    let r = "";
    this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = _s()), !this.supportsBinary && !e.sid && (e.b64 = 1), this.opts.port && (t === "https" && Number(this.opts.port) !== 443 || t === "http" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port);
    const s = bs(e), i = this.opts.hostname.indexOf(":") !== -1;
    return t + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (s.length ? "?" + s : "");
  }
  request(e = {}) {
    return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new ye(this.uri(), e);
  }
  doWrite(e, t) {
    const r = this.request({
      method: "POST",
      data: e
    });
    r.on("success", t), r.on("error", (s, i) => {
      this.onError("xhr post error", s, i);
    });
  }
  doPoll() {
    const e = this.request();
    e.on("data", this.onData.bind(this)), e.on("error", (t, r) => {
      this.onError("xhr poll error", t, r);
    }), this.pollXhr = e;
  }
}
class ye extends K {
  constructor(e, t) {
    super(), jt(this, t), this.opts = t, this.method = t.method || "GET", this.uri = e, this.async = t.async !== !1, this.data = t.data !== void 0 ? t.data : null, this.create();
  }
  create() {
    const e = ys(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs;
    const t = this.xhr = new Es(e);
    try {
      t.open(this.method, this.uri, this.async);
      try {
        if (this.opts.extraHeaders) {
          t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0);
          for (let r in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(r) && t.setRequestHeader(r, this.opts.extraHeaders[r]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          t.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        t.setRequestHeader("Accept", "*/*");
      } catch {
      }
      "withCredentials" in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), t.onreadystatechange = () => {
        t.readyState === 4 && (t.status === 200 || t.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof t.status == "number" ? t.status : 0);
        }, 0));
      }, t.send(this.data);
    } catch (r) {
      this.setTimeoutFn(() => {
        this.onError(r);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = ye.requestsCount++, ye.requests[this.index] = this);
  }
  onError(e) {
    this.emitReserved("error", e, this.xhr), this.cleanup(!0);
  }
  cleanup(e) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = zo, e)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete ye.requests[this.index], this.xhr = null;
    }
  }
  onLoad() {
    const e = this.xhr.responseText;
    e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this.cleanup());
  }
  abort() {
    this.cleanup();
  }
}
ye.requestsCount = 0;
ye.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", kr);
  else if (typeof addEventListener == "function") {
    const n = "onpagehide" in Le ? "pagehide" : "unload";
    addEventListener(n, kr, !1);
  }
}
function kr() {
  for (let n in ye.requests)
    ye.requests.hasOwnProperty(n) && ye.requests[n].abort();
}
const Xo = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0))(), Ct = Le.WebSocket || Le.MozWebSocket, Nr = !0, Qo = "arraybuffer", Pr = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class Zo extends ms {
  constructor(e) {
    super(e), this.supportsBinary = !e.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const e = this.uri(), t = this.opts.protocols, r = Pr ? {} : ys(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = Nr && !Pr ? t ? new Ct(e, t) : new Ct(e) : new Ct(e, t, r);
    } catch (s) {
      return this.emitReserved("error", s);
    }
    this.ws.binaryType = this.socket.binaryType || Qo, this.addEventListeners();
  }
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (e) => this.onClose({
      description: "websocket connection closed",
      context: e
    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError("websocket error", e);
  }
  write(e) {
    this.writable = !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], s = t === e.length - 1;
      fs(r, this.supportsBinary, (i) => {
        const o = {};
        try {
          Nr && this.ws.send(i);
        } catch {
        }
        s && Xo(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  uri() {
    let e = this.query || {};
    const t = this.opts.secure ? "wss" : "ws";
    let r = "";
    this.opts.port && (t === "wss" && Number(this.opts.port) !== 443 || t === "ws" && Number(this.opts.port) !== 80) && (r = ":" + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = _s()), this.supportsBinary || (e.b64 = 1);
    const s = bs(e), i = this.opts.hostname.indexOf(":") !== -1;
    return t + "://" + (i ? "[" + this.opts.hostname + "]" : this.opts.hostname) + r + this.opts.path + (s.length ? "?" + s : "");
  }
  check() {
    return !!Ct;
  }
}
const ea = {
  websocket: Zo,
  polling: Go
}, ta = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, na = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function On(n) {
  const e = n, t = n.indexOf("["), r = n.indexOf("]");
  t != -1 && r != -1 && (n = n.substring(0, t) + n.substring(t, r).replace(/:/g, ";") + n.substring(r, n.length));
  let s = ta.exec(n || ""), i = {}, o = 14;
  for (; o--; )
    i[na[o]] = s[o] || "";
  return t != -1 && r != -1 && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, ":"), i.authority = i.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), i.ipv6uri = !0), i.pathNames = ra(i, i.path), i.queryKey = sa(i, i.query), i;
}
function ra(n, e) {
  const t = /\/{2,9}/g, r = e.replace(t, "/").split("/");
  return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function sa(n, e) {
  const t = {};
  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, i) {
    s && (t[s] = i);
  }), t;
}
class Ce extends K {
  constructor(e, t = {}) {
    super(), e && typeof e == "object" && (t = e, e = null), e ? (e = On(e), t.hostname = e.host, t.secure = e.protocol === "https" || e.protocol === "wss", t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = On(t.host).host), jt(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = t.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !0
    }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + "/", typeof this.opts.query == "string" && (this.opts.query = Yo(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  createTransport(e) {
    const t = Object.assign({}, this.opts.query);
    t.EIO = vs, t.transport = e, this.id && (t.sid = this.id);
    const r = Object.assign({}, this.opts.transportOptions[e], this.opts, {
      query: t,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    });
    return new ea[e](r);
  }
  open() {
    let e;
    if (this.opts.rememberUpgrade && Ce.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      e = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      e = this.transports[0];
    this.readyState = "opening";
    try {
      e = this.createTransport(e);
    } catch {
      this.transports.shift(), this.open();
      return;
    }
    e.open(), this.setTransport(e);
  }
  setTransport(e) {
    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (t) => this.onClose("transport close", t));
  }
  probe(e) {
    let t = this.createTransport(e), r = !1;
    Ce.priorWebsocketSuccess = !1;
    const s = () => {
      r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", (l) => {
        if (!r)
          if (l.type === "pong" && l.data === "probe") {
            if (this.upgrading = !0, this.emitReserved("upgrading", t), !t)
              return;
            Ce.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => {
              r || this.readyState !== "closed" && (h(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush());
            });
          } else {
            const p = new Error("probe error");
            p.transport = t.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function i() {
      r || (r = !0, h(), t.close(), t = null);
    }
    const o = (l) => {
      const p = new Error("probe error: " + l);
      p.transport = t.name, i(), this.emitReserved("upgradeError", p);
    };
    function c() {
      o("transport closed");
    }
    function f() {
      o("socket closed");
    }
    function a(l) {
      t && l.name !== t.name && i();
    }
    const h = () => {
      t.removeListener("open", s), t.removeListener("error", o), t.removeListener("close", c), this.off("close", f), this.off("upgrading", a);
    };
    t.once("open", s), t.once("error", o), t.once("close", c), this.once("close", f), this.once("upgrading", a), t.open();
  }
  onOpen() {
    if (this.readyState = "open", Ce.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
      let e = 0;
      const t = this.upgrades.length;
      for (; e < t; e++)
        this.probe(this.upgrades[e]);
    }
  }
  onPacket(e) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) {
        case "open":
          this.onHandshake(JSON.parse(e.data));
          break;
        case "ping":
          this.resetPingTimeout(), this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const t = new Error("server error");
          t.code = e.data, this.onError(t);
          break;
        case "message":
          this.emitReserved("data", e.data), this.emitReserved("message", e.data);
          break;
      }
  }
  onHandshake(e) {
    this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const e = this.getWritablePackets();
      this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved("flush");
    }
  }
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let t = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const s = this.writeBuffer[r].data;
      if (s && (t += $o(s)), r > 0 && t > this.maxPayload)
        return this.writeBuffer.slice(0, r);
      t += 2;
    }
    return this.writeBuffer;
  }
  write(e, t, r) {
    return this.sendPacket("message", e, t, r), this;
  }
  send(e, t, r) {
    return this.sendPacket("message", e, t, r), this;
  }
  sendPacket(e, t, r, s) {
    if (typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const i = {
      type: e,
      data: t,
      options: r
    };
    this.emitReserved("packetCreate", i), this.writeBuffer.push(i), s && this.once("flush", s), this.flush();
  }
  close() {
    const e = () => {
      this.onClose("forced close"), this.transport.close();
    }, t = () => {
      this.off("upgrade", t), this.off("upgradeError", t), e();
    }, r = () => {
      this.once("upgrade", t), this.once("upgradeError", t);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : e();
    }) : this.upgrading ? r() : e()), this;
  }
  onError(e) {
    Ce.priorWebsocketSuccess = !1, this.emitReserved("error", e), this.onClose("transport error", e);
  }
  onClose(e, t) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  filterUpgrades(e) {
    const t = [];
    let r = 0;
    const s = e.length;
    for (; r < s; r++)
      ~this.transports.indexOf(e[r]) && t.push(e[r]);
    return t;
  }
}
Ce.protocol = vs;
function ia(n, e = "", t) {
  let r = n;
  t = t || typeof location < "u" && location, n == null && (n = t.protocol + "//" + t.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = t.protocol + n : n = t.host + n), /^(https?|wss?):\/\//.test(n) || (typeof t < "u" ? n = t.protocol + "//" + n : n = "https://" + n), r = On(n)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const i = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + i + ":" + r.port + e, r.href = r.protocol + "://" + i + (t && t.port === r.port ? "" : ":" + r.port), r;
}
const oa = typeof ArrayBuffer == "function", aa = (n) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Rs = Object.prototype.toString, ua = typeof Blob == "function" || typeof Blob < "u" && Rs.call(Blob) === "[object BlobConstructor]", ca = typeof File == "function" || typeof File < "u" && Rs.call(File) === "[object FileConstructor]";
function Un(n) {
  return oa && (n instanceof ArrayBuffer || aa(n)) || ua && n instanceof Blob || ca && n instanceof File;
}
function kt(n, e) {
  if (!n || typeof n != "object")
    return !1;
  if (Array.isArray(n)) {
    for (let t = 0, r = n.length; t < r; t++)
      if (kt(n[t]))
        return !0;
    return !1;
  }
  if (Un(n))
    return !0;
  if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1)
    return kt(n.toJSON(), !0);
  for (const t in n)
    if (Object.prototype.hasOwnProperty.call(n, t) && kt(n[t]))
      return !0;
  return !1;
}
function la(n) {
  const e = [], t = n.data, r = n;
  return r.data = xn(t, e), r.attachments = e.length, { packet: r, buffers: e };
}
function xn(n, e) {
  if (!n)
    return n;
  if (Un(n)) {
    const t = { _placeholder: !0, num: e.length };
    return e.push(n), t;
  } else if (Array.isArray(n)) {
    const t = new Array(n.length);
    for (let r = 0; r < n.length; r++)
      t[r] = xn(n[r], e);
    return t;
  } else if (typeof n == "object" && !(n instanceof Date)) {
    const t = {};
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = xn(n[r], e));
    return t;
  }
  return n;
}
function fa(n, e) {
  return n.data = Cn(n.data, e), delete n.attachments, n;
}
function Cn(n, e) {
  if (!n)
    return n;
  if (n && n._placeholder === !0) {
    if (typeof n.num == "number" && n.num >= 0 && n.num < e.length)
      return e[n.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(n))
    for (let t = 0; t < n.length; t++)
      n[t] = Cn(n[t], e);
  else if (typeof n == "object")
    for (const t in n)
      Object.prototype.hasOwnProperty.call(n, t) && (n[t] = Cn(n[t], e));
  return n;
}
const ha = [
  "connect",
  "connect_error",
  "disconnect",
  "disconnecting",
  "newListener",
  "removeListener"
], da = 5;
var S;
(function(n) {
  n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK";
})(S || (S = {}));
class pa {
  constructor(e) {
    this.replacer = e;
  }
  encode(e) {
    return (e.type === S.EVENT || e.type === S.ACK) && kt(e) ? this.encodeAsBinary({
      type: e.type === S.EVENT ? S.BINARY_EVENT : S.BINARY_ACK,
      nsp: e.nsp,
      data: e.data,
      id: e.id
    }) : [this.encodeAsString(e)];
  }
  encodeAsString(e) {
    let t = "" + e.type;
    return (e.type === S.BINARY_EVENT || e.type === S.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;
  }
  encodeAsBinary(e) {
    const t = la(e), r = this.encodeAsString(t.packet), s = t.buffers;
    return s.unshift(r), s;
  }
}
function Fr(n) {
  return Object.prototype.toString.call(n) === "[object Object]";
}
class qn extends K {
  constructor(e) {
    super(), this.reviver = e;
  }
  add(e) {
    let t;
    if (typeof e == "string") {
      if (this.reconstructor)
        throw new Error("got plaintext data when reconstructing a packet");
      t = this.decodeString(e);
      const r = t.type === S.BINARY_EVENT;
      r || t.type === S.BINARY_ACK ? (t.type = r ? S.EVENT : S.ACK, this.reconstructor = new va(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t);
    } else if (Un(e) || e.base64)
      if (this.reconstructor)
        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t));
      else
        throw new Error("got binary data when not reconstructing a packet");
    else
      throw new Error("Unknown type: " + e);
  }
  decodeString(e) {
    let t = 0;
    const r = {
      type: Number(e.charAt(0))
    };
    if (S[r.type] === void 0)
      throw new Error("unknown packet type " + r.type);
    if (r.type === S.BINARY_EVENT || r.type === S.BINARY_ACK) {
      const i = t + 1;
      for (; e.charAt(++t) !== "-" && t != e.length; )
        ;
      const o = e.substring(i, t);
      if (o != Number(o) || e.charAt(t) !== "-")
        throw new Error("Illegal attachments");
      r.attachments = Number(o);
    }
    if (e.charAt(t + 1) === "/") {
      const i = t + 1;
      for (; ++t && !(e.charAt(t) === "," || t === e.length); )
        ;
      r.nsp = e.substring(i, t);
    } else
      r.nsp = "/";
    const s = e.charAt(t + 1);
    if (s !== "" && Number(s) == s) {
      const i = t + 1;
      for (; ++t; ) {
        const o = e.charAt(t);
        if (o == null || Number(o) != o) {
          --t;
          break;
        }
        if (t === e.length)
          break;
      }
      r.id = Number(e.substring(i, t + 1));
    }
    if (e.charAt(++t)) {
      const i = this.tryParse(e.substr(t));
      if (qn.isPayloadValid(r.type, i))
        r.data = i;
      else
        throw new Error("invalid payload");
    }
    return r;
  }
  tryParse(e) {
    try {
      return JSON.parse(e, this.reviver);
    } catch {
      return !1;
    }
  }
  static isPayloadValid(e, t) {
    switch (e) {
      case S.CONNECT:
        return Fr(t);
      case S.DISCONNECT:
        return t === void 0;
      case S.CONNECT_ERROR:
        return typeof t == "string" || Fr(t);
      case S.EVENT:
      case S.BINARY_EVENT:
        return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && ha.indexOf(t[0]) === -1);
      case S.ACK:
      case S.BINARY_ACK:
        return Array.isArray(t);
    }
  }
  destroy() {
    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
  }
}
class va {
  constructor(e) {
    this.packet = e, this.buffers = [], this.reconPack = e;
  }
  takeBinaryData(e) {
    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {
      const t = fa(this.reconPack, this.buffers);
      return this.finishedReconstruction(), t;
    }
    return null;
  }
  finishedReconstruction() {
    this.reconPack = null, this.buffers = [];
  }
}
const ya = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  protocol: da,
  get PacketType() {
    return S;
  },
  Encoder: pa,
  Decoder: qn
}, Symbol.toStringTag, { value: "Module" }));
function de(n, e, t) {
  return n.on(e, t), function() {
    n.off(e, t);
  };
}
const ma = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  newListener: 1,
  removeListener: 1
});
class Ss extends K {
  constructor(e, t, r) {
    super(), this.connected = !1, this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open();
  }
  get disconnected() {
    return !this.connected;
  }
  subEvents() {
    if (this.subs)
      return;
    const e = this.io;
    this.subs = [
      de(e, "open", this.onopen.bind(this)),
      de(e, "packet", this.onpacket.bind(this)),
      de(e, "error", this.onerror.bind(this)),
      de(e, "close", this.onclose.bind(this))
    ];
  }
  get active() {
    return !!this.subs;
  }
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  open() {
    return this.connect();
  }
  send(...e) {
    return e.unshift("message"), this.emit.apply(this, e), this;
  }
  emit(e, ...t) {
    if (ma.hasOwnProperty(e))
      throw new Error('"' + e + '" is a reserved event name');
    t.unshift(e);
    const r = {
      type: S.EVENT,
      data: t
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") {
      const o = this.ids++, c = t.pop();
      this._registerAckCallback(o, c), r.id = o;
    }
    const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;
  }
  _registerAckCallback(e, t) {
    const r = this.flags.timeout;
    if (r === void 0) {
      this.acks[e] = t;
      return;
    }
    const s = this.io.setTimeoutFn(() => {
      delete this.acks[e];
      for (let i = 0; i < this.sendBuffer.length; i++)
        this.sendBuffer[i].id === e && this.sendBuffer.splice(i, 1);
      t.call(this, new Error("operation has timed out"));
    }, r);
    this.acks[e] = (...i) => {
      this.io.clearTimeoutFn(s), t.apply(this, [null, ...i]);
    };
  }
  packet(e) {
    e.nsp = this.nsp, this.io._packet(e);
  }
  onopen() {
    typeof this.auth == "function" ? this.auth((e) => {
      this.packet({ type: S.CONNECT, data: e });
    }) : this.packet({ type: S.CONNECT, data: this.auth });
  }
  onerror(e) {
    this.connected || this.emitReserved("connect_error", e);
  }
  onclose(e, t) {
    this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t);
  }
  onpacket(e) {
    if (e.nsp === this.nsp)
      switch (e.type) {
        case S.CONNECT:
          if (e.data && e.data.sid) {
            const s = e.data.sid;
            this.onconnect(s);
          } else
            this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case S.EVENT:
        case S.BINARY_EVENT:
          this.onevent(e);
          break;
        case S.ACK:
        case S.BINARY_ACK:
          this.onack(e);
          break;
        case S.DISCONNECT:
          this.ondisconnect();
          break;
        case S.CONNECT_ERROR:
          this.destroy();
          const r = new Error(e.data.message);
          r.data = e.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  onevent(e) {
    const t = e.data || [];
    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));
  }
  emitEvent(e) {
    if (this._anyListeners && this._anyListeners.length) {
      const t = this._anyListeners.slice();
      for (const r of t)
        r.apply(this, e);
    }
    super.emit.apply(this, e);
  }
  ack(e) {
    const t = this;
    let r = !1;
    return function(...s) {
      r || (r = !0, t.packet({
        type: S.ACK,
        id: e,
        data: s
      }));
    };
  }
  onack(e) {
    const t = this.acks[e.id];
    typeof t == "function" && (t.apply(this, e.data), delete this.acks[e.id]);
  }
  onconnect(e) {
    this.id = e, this.connected = !0, this.emitBuffered(), this.emitReserved("connect");
  }
  emitBuffered() {
    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {
      this.notifyOutgoingListeners(e), this.packet(e);
    }), this.sendBuffer = [];
  }
  ondisconnect() {
    this.destroy(), this.onclose("io server disconnect");
  }
  destroy() {
    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);
  }
  disconnect() {
    return this.connected && this.packet({ type: S.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  close() {
    return this.disconnect();
  }
  compress(e) {
    return this.flags.compress = e, this;
  }
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  timeout(e) {
    return this.flags.timeout = e, this;
  }
  onAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;
  }
  prependAny(e) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;
  }
  offAny(e) {
    if (!this._anyListeners)
      return this;
    if (e) {
      const t = this._anyListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  listenersAny() {
    return this._anyListeners || [];
  }
  onAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;
  }
  prependAnyOutgoing(e) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;
  }
  offAnyOutgoing(e) {
    if (!this._anyOutgoingListeners)
      return this;
    if (e) {
      const t = this._anyOutgoingListeners;
      for (let r = 0; r < t.length; r++)
        if (e === t[r])
          return t.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  notifyOutgoingListeners(e) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const t = this._anyOutgoingListeners.slice();
      for (const r of t)
        r.apply(this, e.data);
    }
  }
}
function Qe(n) {
  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;
}
Qe.prototype.duration = function() {
  var n = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var e = Math.random(), t = Math.floor(e * this.jitter * n);
    n = (Math.floor(e * 10) & 1) == 0 ? n - t : n + t;
  }
  return Math.min(n, this.max) | 0;
};
Qe.prototype.reset = function() {
  this.attempts = 0;
};
Qe.prototype.setMin = function(n) {
  this.ms = n;
};
Qe.prototype.setMax = function(n) {
  this.max = n;
};
Qe.prototype.setJitter = function(n) {
  this.jitter = n;
};
class An extends K {
  constructor(e, t) {
    var r;
    super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, jt(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Qe({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e;
    const s = t.parser || ya;
    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(e) {
    return arguments.length ? (this._reconnection = !!e, this) : this._reconnection;
  }
  reconnectionAttempts(e) {
    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);
  }
  reconnectionDelay(e) {
    var t;
    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);
  }
  randomizationFactor(e) {
    var t;
    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);
  }
  reconnectionDelayMax(e) {
    var t;
    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);
  }
  timeout(e) {
    return arguments.length ? (this._timeout = e, this) : this._timeout;
  }
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  open(e) {
    if (~this._readyState.indexOf("open"))
      return this;
    this.engine = new Ce(this.uri, this.opts);
    const t = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const s = de(t, "open", function() {
      r.onopen(), e && e();
    }), i = de(t, "error", (o) => {
      r.cleanup(), r._readyState = "closed", this.emitReserved("error", o), e ? e(o) : r.maybeReconnectOnOpen();
    });
    if (this._timeout !== !1) {
      const o = this._timeout;
      o === 0 && s();
      const c = this.setTimeoutFn(() => {
        s(), t.close(), t.emit("error", new Error("timeout"));
      }, o);
      this.opts.autoUnref && c.unref(), this.subs.push(function() {
        clearTimeout(c);
      });
    }
    return this.subs.push(s), this.subs.push(i), this;
  }
  connect(e) {
    return this.open(e);
  }
  onopen() {
    this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const e = this.engine;
    this.subs.push(de(e, "ping", this.onping.bind(this)), de(e, "data", this.ondata.bind(this)), de(e, "error", this.onerror.bind(this)), de(e, "close", this.onclose.bind(this)), de(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  onping() {
    this.emitReserved("ping");
  }
  ondata(e) {
    this.decoder.add(e);
  }
  ondecoded(e) {
    this.emitReserved("packet", e);
  }
  onerror(e) {
    this.emitReserved("error", e);
  }
  socket(e, t) {
    let r = this.nsps[e];
    return r || (r = new Ss(this, e, t), this.nsps[e] = r), r;
  }
  _destroy(e) {
    const t = Object.keys(this.nsps);
    for (const r of t)
      if (this.nsps[r].active)
        return;
    this._close();
  }
  _packet(e) {
    const t = this.encoder.encode(e);
    for (let r = 0; r < t.length; r++)
      this.engine.write(t[r], e.options);
  }
  cleanup() {
    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();
  }
  _close() {
    this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  disconnect() {
    return this._close();
  }
  onclose(e, t) {
    this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const e = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const t = this.backoff.duration();
      this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open((s) => {
          s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", s)) : e.onreconnect();
        }));
      }, t);
      this.opts.autoUnref && r.unref(), this.subs.push(function() {
        clearTimeout(r);
      });
    }
  }
  onreconnect() {
    const e = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e);
  }
}
const it = {};
function Nt(n, e) {
  typeof n == "object" && (e = n, n = void 0), e = e || {};
  const t = ia(n, e.path || "/socket.io"), r = t.source, s = t.id, i = t.path, o = it[s] && i in it[s].nsps, c = e.forceNew || e["force new connection"] || e.multiplex === !1 || o;
  let f;
  return c ? f = new An(r, e) : (it[s] || (it[s] = new An(r, e)), f = it[s]), t.query && !e.query && (e.query = t.queryKey), f.socket(t.path, e);
}
Object.assign(Nt, {
  Manager: An,
  Socket: Ss,
  io: Nt,
  connect: Nt
});
class ga {
  constructor(e, t, r) {
    Fe(this, "socket_port");
    Fe(this, "host");
    Fe(this, "port");
    Fe(this, "protocol");
    Fe(this, "url");
    Fe(this, "socket");
    var s, i;
    this.socket_port = t != null ? t : "9000", this.host = (s = window.location) == null ? void 0 : s.hostname, this.port = (i = window.location) != null && i.port ? `:${this.socket_port}` : "", this.protocol = this.port ? "http" : "https", this.url = e || `${this.protocol}://${this.host}${this.port}`, this.socket = Nt(this.url, {
      withCredentials: !0,
      extraHeaders: r && r.useToken === !0 ? {
        Authorization: `${r.type} ${r.token}`
      } : {}
    });
  }
}
var Ts = { exports: {} }, ot = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Br;
function _a() {
  if (Br)
    return ot;
  Br = 1;
  var n = qe, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(c, f, a) {
    var h, l = {}, p = null, v = null;
    a !== void 0 && (p = "" + a), f.key !== void 0 && (p = "" + f.key), f.ref !== void 0 && (v = f.ref);
    for (h in f)
      r.call(f, h) && !i.hasOwnProperty(h) && (l[h] = f[h]);
    if (c && c.defaultProps)
      for (h in f = c.defaultProps, f)
        l[h] === void 0 && (l[h] = f[h]);
    return { $$typeof: e, type: c, key: p, ref: v, props: l, _owner: s.current };
  }
  return ot.Fragment = t, ot.jsx = o, ot.jsxs = o, ot;
}
var at = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ir;
function ba() {
  return Ir || (Ir = 1, process.env.NODE_ENV !== "production" && function() {
    var n = qe, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), c = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), a = Symbol.for("react.suspense"), h = Symbol.for("react.suspense_list"), l = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), b = Symbol.iterator, w = "@@iterator";
    function x(u) {
      if (u === null || typeof u != "object")
        return null;
      var d = b && u[b] || u[w];
      return typeof d == "function" ? d : null;
    }
    var g = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function T(u) {
      {
        for (var d = arguments.length, y = new Array(d > 1 ? d - 1 : 0), _ = 1; _ < d; _++)
          y[_ - 1] = arguments[_];
        D("error", u, y);
      }
    }
    function D(u, d, y) {
      {
        var _ = g.ReactDebugCurrentFrame, A = _.getStackAddendum();
        A !== "" && (d += "%s", y = y.concat([A]));
        var I = y.map(function(O) {
          return String(O);
        });
        I.unshift("Warning: " + d), Function.prototype.apply.call(console[u], console, I);
      }
    }
    var m = !1, V = !1, U = !1, L = !1, E = !1, j;
    j = Symbol.for("react.module.reference");
    function k(u) {
      return !!(typeof u == "string" || typeof u == "function" || u === r || u === i || E || u === s || u === a || u === h || L || u === v || m || V || U || typeof u == "object" && u !== null && (u.$$typeof === p || u.$$typeof === l || u.$$typeof === o || u.$$typeof === c || u.$$typeof === f || u.$$typeof === j || u.getModuleId !== void 0));
    }
    function X(u, d, y) {
      var _ = u.displayName;
      if (_)
        return _;
      var A = d.displayName || d.name || "";
      return A !== "" ? y + "(" + A + ")" : y;
    }
    function ne(u) {
      return u.displayName || "Context";
    }
    function Z(u) {
      if (u == null)
        return null;
      if (typeof u.tag == "number" && T("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof u == "function")
        return u.displayName || u.name || null;
      if (typeof u == "string")
        return u;
      switch (u) {
        case r:
          return "Fragment";
        case t:
          return "Portal";
        case i:
          return "Profiler";
        case s:
          return "StrictMode";
        case a:
          return "Suspense";
        case h:
          return "SuspenseList";
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case c:
            var d = u;
            return ne(d) + ".Consumer";
          case o:
            var y = u;
            return ne(y._context) + ".Provider";
          case f:
            return X(u, u.render, "ForwardRef");
          case l:
            var _ = u.displayName || null;
            return _ !== null ? _ : Z(u.type) || "Memo";
          case p: {
            var A = u, I = A._payload, O = A._init;
            try {
              return Z(O(I));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var $ = Object.assign, _e = 0, be, Ze, we, et, yt, Ee, Re;
    function Ne() {
    }
    Ne.__reactDisabledLog = !0;
    function mt() {
      {
        if (_e === 0) {
          be = console.log, Ze = console.info, we = console.warn, et = console.error, yt = console.group, Ee = console.groupCollapsed, Re = console.groupEnd;
          var u = {
            configurable: !0,
            enumerable: !0,
            value: Ne,
            writable: !0
          };
          Object.defineProperties(console, {
            info: u,
            log: u,
            warn: u,
            error: u,
            group: u,
            groupCollapsed: u,
            groupEnd: u
          });
        }
        _e++;
      }
    }
    function Ve() {
      {
        if (_e--, _e === 0) {
          var u = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: $({}, u, {
              value: be
            }),
            info: $({}, u, {
              value: Ze
            }),
            warn: $({}, u, {
              value: we
            }),
            error: $({}, u, {
              value: et
            }),
            group: $({}, u, {
              value: yt
            }),
            groupCollapsed: $({}, u, {
              value: Ee
            }),
            groupEnd: $({}, u, {
              value: Re
            })
          });
        }
        _e < 0 && T("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var je = g.ReactCurrentDispatcher, $e;
    function Me(u, d, y) {
      {
        if ($e === void 0)
          try {
            throw Error();
          } catch (A) {
            var _ = A.stack.trim().match(/\n( *(at )?)/);
            $e = _ && _[1] || "";
          }
        return `
` + $e + u;
      }
    }
    var tt = !1, pe;
    {
      var gt = typeof WeakMap == "function" ? WeakMap : Map;
      pe = new gt();
    }
    function N(u, d) {
      if (!u || tt)
        return "";
      {
        var y = pe.get(u);
        if (y !== void 0)
          return y;
      }
      var _;
      tt = !0;
      var A = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var I;
      I = je.current, je.current = null, mt();
      try {
        if (d) {
          var O = function() {
            throw Error();
          };
          if (Object.defineProperty(O.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(O, []);
            } catch (Te) {
              _ = Te;
            }
            Reflect.construct(u, [], O);
          } else {
            try {
              O.call();
            } catch (Te) {
              _ = Te;
            }
            u.call(O.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            _ = Te;
          }
          u();
        }
      } catch (Te) {
        if (Te && _ && typeof Te.stack == "string") {
          for (var R = Te.stack.split(`
`), se = _.stack.split(`
`), W = R.length - 1, J = se.length - 1; W >= 1 && J >= 0 && R[W] !== se[J]; )
            J--;
          for (; W >= 1 && J >= 0; W--, J--)
            if (R[W] !== se[J]) {
              if (W !== 1 || J !== 1)
                do
                  if (W--, J--, J < 0 || R[W] !== se[J]) {
                    var ce = `
` + R[W].replace(" at new ", " at ");
                    return u.displayName && ce.includes("<anonymous>") && (ce = ce.replace("<anonymous>", u.displayName)), typeof u == "function" && pe.set(u, ce), ce;
                  }
                while (W >= 1 && J >= 0);
              break;
            }
        }
      } finally {
        tt = !1, je.current = I, Ve(), Error.prepareStackTrace = A;
      }
      var Je = u ? u.displayName || u.name : "", zn = Je ? Me(Je) : "";
      return typeof u == "function" && pe.set(u, zn), zn;
    }
    function B(u, d, y) {
      return N(u, !1);
    }
    function G(u) {
      var d = u.prototype;
      return !!(d && d.isReactComponent);
    }
    function q(u, d, y) {
      if (u == null)
        return "";
      if (typeof u == "function")
        return N(u, G(u));
      if (typeof u == "string")
        return Me(u);
      switch (u) {
        case a:
          return Me("Suspense");
        case h:
          return Me("SuspenseList");
      }
      if (typeof u == "object")
        switch (u.$$typeof) {
          case f:
            return B(u.render);
          case l:
            return q(u.type, d, y);
          case p: {
            var _ = u, A = _._payload, I = _._init;
            try {
              return q(I(A), d, y);
            } catch {
            }
          }
        }
      return "";
    }
    var re = Object.prototype.hasOwnProperty, Se = {}, H = g.ReactDebugCurrentFrame;
    function Y(u) {
      if (u) {
        var d = u._owner, y = q(u.type, u._source, d ? d.type : null);
        H.setExtraStackFrame(y);
      } else
        H.setExtraStackFrame(null);
    }
    function he(u, d, y, _, A) {
      {
        var I = Function.call.bind(re);
        for (var O in u)
          if (I(u, O)) {
            var R = void 0;
            try {
              if (typeof u[O] != "function") {
                var se = Error((_ || "React class") + ": " + y + " type `" + O + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof u[O] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw se.name = "Invariant Violation", se;
              }
              R = u[O](d, O, _, y, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (W) {
              R = W;
            }
            R && !(R instanceof Error) && (Y(A), T("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _ || "React class", y, O, typeof R), Y(null)), R instanceof Error && !(R.message in Se) && (Se[R.message] = !0, Y(A), T("Failed %s type: %s", y, R.message), Y(null));
          }
      }
    }
    var _t = Array.isArray;
    function We(u) {
      return _t(u);
    }
    function bt(u) {
      {
        var d = typeof Symbol == "function" && Symbol.toStringTag, y = d && u[Symbol.toStringTag] || u.constructor.name || "Object";
        return y;
      }
    }
    function ie(u) {
      try {
        return ue(u), !1;
      } catch {
        return !0;
      }
    }
    function ue(u) {
      return "" + u;
    }
    function He(u) {
      if (ie(u))
        return T("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", bt(u)), ue(u);
    }
    var Pe = g.ReactCurrentOwner, nt = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Vn, jn, $t;
    $t = {};
    function Cs(u) {
      if (re.call(u, "ref")) {
        var d = Object.getOwnPropertyDescriptor(u, "ref").get;
        if (d && d.isReactWarning)
          return !1;
      }
      return u.ref !== void 0;
    }
    function As(u) {
      if (re.call(u, "key")) {
        var d = Object.getOwnPropertyDescriptor(u, "key").get;
        if (d && d.isReactWarning)
          return !1;
      }
      return u.key !== void 0;
    }
    function Ls(u, d) {
      if (typeof u.ref == "string" && Pe.current && d && Pe.current.stateNode !== d) {
        var y = Z(Pe.current.type);
        $t[y] || (T('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Z(Pe.current.type), u.ref), $t[y] = !0);
      }
    }
    function Ds(u, d) {
      {
        var y = function() {
          Vn || (Vn = !0, T("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", d));
        };
        y.isReactWarning = !0, Object.defineProperty(u, "key", {
          get: y,
          configurable: !0
        });
      }
    }
    function ks(u, d) {
      {
        var y = function() {
          jn || (jn = !0, T("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", d));
        };
        y.isReactWarning = !0, Object.defineProperty(u, "ref", {
          get: y,
          configurable: !0
        });
      }
    }
    var Ns = function(u, d, y, _, A, I, O) {
      var R = {
        $$typeof: e,
        type: u,
        key: d,
        ref: y,
        props: O,
        _owner: I
      };
      return R._store = {}, Object.defineProperty(R._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(R, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: _
      }), Object.defineProperty(R, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: A
      }), Object.freeze && (Object.freeze(R.props), Object.freeze(R)), R;
    };
    function Ps(u, d, y, _, A) {
      {
        var I, O = {}, R = null, se = null;
        y !== void 0 && (He(y), R = "" + y), As(d) && (He(d.key), R = "" + d.key), Cs(d) && (se = d.ref, Ls(d, A));
        for (I in d)
          re.call(d, I) && !nt.hasOwnProperty(I) && (O[I] = d[I]);
        if (u && u.defaultProps) {
          var W = u.defaultProps;
          for (I in W)
            O[I] === void 0 && (O[I] = W[I]);
        }
        if (R || se) {
          var J = typeof u == "function" ? u.displayName || u.name || "Unknown" : u;
          R && Ds(O, J), se && ks(O, J);
        }
        return Ns(u, R, se, A, _, Pe.current, O);
      }
    }
    var Mt = g.ReactCurrentOwner, $n = g.ReactDebugCurrentFrame;
    function Ye(u) {
      if (u) {
        var d = u._owner, y = q(u.type, u._source, d ? d.type : null);
        $n.setExtraStackFrame(y);
      } else
        $n.setExtraStackFrame(null);
    }
    var Wt;
    Wt = !1;
    function Ht(u) {
      return typeof u == "object" && u !== null && u.$$typeof === e;
    }
    function Mn() {
      {
        if (Mt.current) {
          var u = Z(Mt.current.type);
          if (u)
            return `

Check the render method of \`` + u + "`.";
        }
        return "";
      }
    }
    function Fs(u) {
      {
        if (u !== void 0) {
          var d = u.fileName.replace(/^.*[\\\/]/, ""), y = u.lineNumber;
          return `

Check your code at ` + d + ":" + y + ".";
        }
        return "";
      }
    }
    var Wn = {};
    function Bs(u) {
      {
        var d = Mn();
        if (!d) {
          var y = typeof u == "string" ? u : u.displayName || u.name;
          y && (d = `

Check the top-level render call using <` + y + ">.");
        }
        return d;
      }
    }
    function Hn(u, d) {
      {
        if (!u._store || u._store.validated || u.key != null)
          return;
        u._store.validated = !0;
        var y = Bs(d);
        if (Wn[y])
          return;
        Wn[y] = !0;
        var _ = "";
        u && u._owner && u._owner !== Mt.current && (_ = " It was passed a child from " + Z(u._owner.type) + "."), Ye(u), T('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', y, _), Ye(null);
      }
    }
    function Yn(u, d) {
      {
        if (typeof u != "object")
          return;
        if (We(u))
          for (var y = 0; y < u.length; y++) {
            var _ = u[y];
            Ht(_) && Hn(_, d);
          }
        else if (Ht(u))
          u._store && (u._store.validated = !0);
        else if (u) {
          var A = x(u);
          if (typeof A == "function" && A !== u.entries)
            for (var I = A.call(u), O; !(O = I.next()).done; )
              Ht(O.value) && Hn(O.value, d);
        }
      }
    }
    function Is(u) {
      {
        var d = u.type;
        if (d == null || typeof d == "string")
          return;
        var y;
        if (typeof d == "function")
          y = d.propTypes;
        else if (typeof d == "object" && (d.$$typeof === f || d.$$typeof === l))
          y = d.propTypes;
        else
          return;
        if (y) {
          var _ = Z(d);
          he(y, u.props, "prop", _, u);
        } else if (d.PropTypes !== void 0 && !Wt) {
          Wt = !0;
          var A = Z(d);
          T("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", A || "Unknown");
        }
        typeof d.getDefaultProps == "function" && !d.getDefaultProps.isReactClassApproved && T("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Us(u) {
      {
        for (var d = Object.keys(u.props), y = 0; y < d.length; y++) {
          var _ = d[y];
          if (_ !== "children" && _ !== "key") {
            Ye(u), T("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _), Ye(null);
            break;
          }
        }
        u.ref !== null && (Ye(u), T("Invalid attribute `ref` supplied to `React.Fragment`."), Ye(null));
      }
    }
    function Jn(u, d, y, _, A, I) {
      {
        var O = k(u);
        if (!O) {
          var R = "";
          (u === void 0 || typeof u == "object" && u !== null && Object.keys(u).length === 0) && (R += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var se = Fs(A);
          se ? R += se : R += Mn();
          var W;
          u === null ? W = "null" : We(u) ? W = "array" : u !== void 0 && u.$$typeof === e ? (W = "<" + (Z(u.type) || "Unknown") + " />", R = " Did you accidentally export a JSX literal instead of a component?") : W = typeof u, T("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", W, R);
        }
        var J = Ps(u, d, y, A, I);
        if (J == null)
          return J;
        if (O) {
          var ce = d.children;
          if (ce !== void 0)
            if (_)
              if (We(ce)) {
                for (var Je = 0; Je < ce.length; Je++)
                  Yn(ce[Je], u);
                Object.freeze && Object.freeze(ce);
              } else
                T("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Yn(ce, u);
        }
        return u === r ? Us(J) : Is(J), J;
      }
    }
    function qs(u, d, y) {
      return Jn(u, d, y, !0);
    }
    function Vs(u, d, y) {
      return Jn(u, d, y, !1);
    }
    var js = Vs, $s = qs;
    at.Fragment = r, at.jsx = js, at.jsxs = $s;
  }()), at;
}
(function(n) {
  process.env.NODE_ENV === "production" ? n.exports = _a() : n.exports = ba();
})(Ts);
const wa = Ts.exports.jsx, te = Ur(null), xa = ({
  url: n = "",
  tokenParams: e,
  socketPort: t,
  enableSocket: r = !0,
  children: s
}) => {
  const i = qr(() => {
    const o = new Xi.FrappeApp(n, e);
    return {
      url: n,
      tokenParams: e,
      app: o,
      auth: o.auth(),
      db: o.db(),
      call: o.call(),
      file: o.file(),
      socket: r ? new ga(n, t, e).socket : void 0,
      enableSocket: r,
      socketPort: t
    };
  }, [n, e, t, r]);
  return /* @__PURE__ */ wa(te.Provider, {
    value: i,
    children: s
  });
}, Ca = (n) => {
  const {
    url: e,
    auth: t,
    tokenParams: r
  } = ee(te), [s, i] = P(), o = M(() => {
    const b = document.cookie.split(";").find((w) => w.trim().startsWith("user_id="));
    if (b) {
      const w = b.split("=")[1];
      i(w && w !== "Guest" ? w : null);
    } else
      i(null);
  }, []);
  Xe(() => {
    r && r.useToken ? i(null) : o();
  }, []);
  const {
    data: c,
    error: f,
    isLoading: a,
    isValidating: h,
    mutate: l
  } = vt(() => r && r.useToken || s ? `${e}/api/method/frappe.auth.get_logged_user` : null, () => t.getLoggedInUser(), {
    onError: () => {
      i(null);
    },
    shouldRetryOnError: !1,
    revalidateOnFocus: !1,
    ...n
  }), p = M(async (b, w) => t.loginWithUsernamePassword({
    username: b,
    password: w
  }).then((x) => {
    o();
  }), []), v = M(async () => t.logout().then(() => l(null)).then(() => i(null)), []);
  return {
    isLoading: s === void 0 || a,
    currentUser: c,
    isValidating: h,
    error: f,
    login: p,
    logout: v,
    updateCurrentUser: l,
    getUserCookie: o
  };
}, Os = (n, e, t) => {
  let r = `${e}/api/resource/`;
  return t ? r += `${n}/${t}` : r += `${n}`, r;
}, Aa = (n, e, t, r) => {
  const {
    url: s,
    db: i
  } = ee(te);
  return {
    ...vt(t === void 0 ? Os(n, s, e) : t, () => i.getDoc(n, e), r)
  };
}, Ea = (n) => {
  var t, r, s;
  let e = "";
  if (n != null && n.fields && (e += "fields=" + JSON.stringify(n == null ? void 0 : n.fields) + "&"), n != null && n.filters && (e += "filters=" + JSON.stringify(n == null ? void 0 : n.filters) + "&"), n != null && n.orFilters && (e += "or_filters=" + JSON.stringify(n == null ? void 0 : n.orFilters) + "&"), n != null && n.limit_start && (e += "limit_start=" + JSON.stringify(n == null ? void 0 : n.limit_start) + "&"), n != null && n.limit && (e += "limit=" + JSON.stringify(n == null ? void 0 : n.limit) + "&"), n != null && n.groupBy && (e += "group_by=" + String(n.groupBy) + "&"), n != null && n.orderBy) {
    const i = `${String((t = n.orderBy) == null ? void 0 : t.field)} ${(s = (r = n.orderBy) == null ? void 0 : r.order) != null ? s : "asc"}`;
    e += "order_by=" + i + "&";
  }
  return n != null && n.asDict && (e += "as_dict=" + n.asDict), e;
}, La = (n, e, t, r) => {
  const {
    url: s,
    db: i
  } = ee(te);
  return {
    ...vt(t === void 0 ? `${Os(n, s)}?${Ea(e)}` : t, () => i.getDocList(n, e), r)
  };
}, Da = () => {
  const {
    db: n
  } = ee(te), [e, t] = P(!1), [r, s] = P(null), [i, o] = P(!1), c = M(() => {
    t(!1), s(null), o(!1);
  }, []);
  return {
    createDoc: M(async (a, h) => (s(null), o(!1), t(!0), n.createDoc(a, h).then((l) => (t(!1), o(!0), l)).catch((l) => {
      throw t(!1), o(!1), s(l), l;
    })), []),
    loading: e,
    error: r,
    isCompleted: i,
    reset: c
  };
}, ka = () => {
  const {
    db: n
  } = ee(te), [e, t] = P(!1), [r, s] = P(null), [i, o] = P(!1), c = M(() => {
    t(!1), s(null), o(!1);
  }, []);
  return {
    updateDoc: M(async (a, h, l) => (s(null), o(!1), t(!0), n.updateDoc(a, h, l).then((p) => (t(!1), o(!0), p)).catch((p) => {
      throw t(!1), o(!1), s(p), p;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
}, Na = () => {
  const {
    db: n
  } = ee(te), [e, t] = P(!1), [r, s] = P(null), [i, o] = P(!1), c = M(() => {
    t(!1), s(null), o(!1);
  }, []);
  return {
    deleteDoc: M(async (a, h) => (s(null), o(!1), t(!0), n.deleteDoc(a, h).then((l) => (t(!1), o(!0), l)).catch((l) => {
      throw t(!1), o(!1), s(l), l;
    })), []),
    loading: e,
    error: r,
    reset: c,
    isCompleted: i
  };
};
function xs(n) {
  const e = [];
  for (let t in n)
    e.push(encodeURIComponent(t) + "=" + encodeURIComponent(n[t]));
  return e.join("&");
}
const Pa = (n, e, t = !1, r = !1, s, i) => {
  const {
    url: o,
    db: c
  } = ee(te);
  return {
    ...vt(s === void 0 ? (() => {
      const h = xs(t ? {
        doctype: n,
        filters: e != null ? e : [],
        cache: t,
        debug: r
      } : {
        doctype: n,
        filters: e != null ? e : [],
        debug: r
      });
      return `${o}/api/method/frappe.client.get_count?${h}`;
    })() : s, () => c.getCount(n, e, t, r), i)
  };
}, Ra = (n, e, t, r) => {
  const {
    call: s
  } = ee(te), i = xs(e != null ? e : {}), o = `${n}?${i}`;
  return {
    ...vt(t === void 0 ? o : t, () => s.get(n, e), r)
  };
}, Fa = (n) => {
  const {
    call: e
  } = ee(te), [t, r] = P(null), [s, i] = P(!1), [o, c] = P(null), [f, a] = P(!1), h = M(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: M(async (p) => (c(null), a(!1), i(!0), r(null), e.post(n, p).then((v) => (r(v), i(!1), a(!0), v)).catch((v) => {
      throw i(!1), a(!1), c(v), v;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: h,
    isCompleted: f
  };
}, Ba = (n) => {
  const {
    call: e
  } = ee(te), [t, r] = P(null), [s, i] = P(!1), [o, c] = P(null), [f, a] = P(!1), h = M(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: M(async (p) => (c(null), a(!1), i(!0), r(null), e.put(n, p).then((v) => (r(v), i(!1), a(!0), v)).catch((v) => {
      throw i(!1), a(!1), c(v), v;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: h,
    isCompleted: f
  };
}, Ia = (n) => {
  const {
    call: e
  } = ee(te), [t, r] = P(null), [s, i] = P(!1), [o, c] = P(null), [f, a] = P(!1), h = M(() => {
    r(null), i(!1), c(null), a(!1);
  }, []);
  return {
    call: M(async (p) => (c(null), a(!1), i(!0), r(null), e.delete(n, p).then((v) => (r(v), i(!1), a(!0), v)).catch((v) => {
      throw i(!1), a(!1), c(v), v;
    })), []),
    result: t,
    loading: s,
    error: o,
    reset: h,
    isCompleted: f
  };
}, Ua = () => {
  const {
    file: n
  } = ee(te), [e, t] = P(0), [r, s] = P(!1), [i, o] = P(null), [c, f] = P(!1), a = M(async (l, p) => (h(), s(!0), n.uploadFile(l, p, (v, b) => t(Math.round(v / b * 100))).then((v) => (f(!0), t(100), s(!1), v.data.message)).catch((v) => {
    throw console.error(v), o(v), s(!1), v;
  })), []), h = M(() => {
    t(0), s(!1), o(null), f(!1);
  }, []);
  return {
    upload: a,
    progress: e,
    loading: r,
    isCompleted: c,
    error: i,
    reset: h
  };
}, qa = (n, e, t = [], r = 20, s = 250) => {
  const i = Sa(e, s);
  return Ra("frappe.desk.search.search_link", {
    doctype: n,
    page_length: r,
    txt: i,
    filters: JSON.stringify(t != null ? t : [])
  });
}, Sa = (n, e) => {
  const [t, r] = P(n);
  return Xe(() => {
    const s = setTimeout(() => {
      r(n);
    }, e);
    return () => {
      clearTimeout(s);
    };
  }, [n, e]), t;
}, Ln = (n, e) => {
  const {
    socket: t
  } = ee(te);
  Xe(() => {
    t === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider.");
    let r = t == null ? void 0 : t.on(n, e);
    return () => {
      r == null || r.off(n);
    };
  }, [n, e]);
}, Va = (n, e, t, r = !0) => {
  const {
    socket: s
  } = ee(te), [i, o] = P([]);
  Xe(() => (s === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider."), s == null || s.emit("doc_subscribe", n, e), r && (s == null || s.emit("doc_open", n, e)), () => {
    s == null || s.emit("doc_unsubscribe", n, e), r && (s == null || s.emit("doc_close", n, e));
  }), [n, e, r]), Ln("doc_update", t);
  const c = M(() => {
    s == null || s.emit("doc_open", n, e);
  }, [n, e]), f = M(() => {
    s == null || s.emit("doc_close", n, e);
  }, [n, e]), a = M((h) => {
    h.doctype === n && h.docname === e && o(h.users);
  }, [n, e]);
  return Ln("doc_viewers", a), {
    viewers: i,
    emitDocOpen: c,
    emitDocClose: f
  };
}, ja = (n, e) => {
  const {
    socket: t
  } = ee(te);
  Xe(() => (t === void 0 && console.warn("Socket is not enabled. Please enable socket in FrappeProvider."), t == null || t.emit("doctype_subscribe", n), () => {
    t == null || t.emit("doctype_unsubscribe", n);
  }), [n]), Ln("list_update", e);
};
export {
  te as FrappeContext,
  xa as FrappeProvider,
  Ea as getDocListQueryString,
  Os as getRequestURL,
  Ca as useFrappeAuth,
  Da as useFrappeCreateDoc,
  Ia as useFrappeDeleteCall,
  Na as useFrappeDeleteDoc,
  ja as useFrappeDocTypeEventListener,
  Va as useFrappeDocumentEventListener,
  Ln as useFrappeEventListener,
  Ua as useFrappeFileUpload,
  Ra as useFrappeGetCall,
  Aa as useFrappeGetDoc,
  Pa as useFrappeGetDocCount,
  La as useFrappeGetDocList,
  Fa as useFrappePostCall,
  Ba as useFrappePutCall,
  ka as useFrappeUpdateDoc,
  qa as useSearch
};
